<!DOCTYPE html>
<html lang='eng'>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta charset="UTF-8">
        <title>Funções Javascript</title>

        <!-- Bootstrap CSS -->
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

        <!-- myGlobalCSS -->
        <link rel="stylesheet" type="text/css" href="https://thiago-meneses.github.io/myGlobalCSS.css">

        <!-- FONTS -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Fira+Mono:wght@400;500;700&family=Fira+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,300&family=Roboto+Mono:wght@100;200;300;400;500;600;700&display=swap" rel="stylesheet">
    </head>
    <body>
        <div class="container-xxl px-4">
            <h1 class="initialTitle">Funções em Javascript</h1>
            <p>
                Funções são definidas pela palavra-chave "function" <br>
                Funções são <b>objetos</b>
            </p>
            <hr>
        </div>

        <div class="container-xxl">
            <div class="bd-content">
                <div class="boundingLines"></div>
                <h1 class="px-4"><mark class="lineText">Propriedades e Métodos</mark></h1>
                <div class="px-4 py-3">
                    <p class="px-4 fs-4">• Funções possuem <b>propriedades</b> e <b>métodos</b>:</p><br>
                    <div class="px-4 py-4">
                        <h2 class="pb-4"><b class="red">Propriedades</b> de uma Função</h2>
                        <p class="px-4 fs-4">• <b>Exemplo:</b> Propriedade <code class="inlineCodeTag">.length</code></p>
                        <div class="px-4">
                            <pre class="px-4 preTag fs-6">
                                <code>
function myFunction(a, b) {
    return arguments<b>.length</b>;
}
console.log(myFunction(4, 3)); //Será retornado "2" no console    
                                </code>
                            </pre>
                        </div>
                        <br><hr>
                    </div>

                    <div class="px-4 py-4">
                        <h2 class="pb-4"><b class="red">Métodos</b> de uma Função</h2>
                        <p class="px-4 fs-4">• <b>Exemplo:</b> Método <code class="inlineCodeTag">.toString()</code></p>
                        <div class="px-4">
                            <pre class="preTag px-4">
                                <code>
function myFunction(a, b) {
return a * b;
}
console.log( myFunction.toString() );	//Irá retornar "function myFunction(a, b) { return a * b; }" no console
                                </code>
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="container-xxl">
            <div class="bd-content">
                <div class="boundingLines"></div>
                <h1 class="px-4"><mark class="lineText">Declaration vs Expression</mark></h1>
                <div class="px-5 py-3">
                    <h2 class="pb-4">Function <b class="red">Declaration</b></h2>
                    <ul>
                        <li>Funções declaradas <b>NÃO</b> são <b>executadas imediatamente</b>; </li>
                        <li>São executadas apenas quando <b>invocadas</b>;</li>
                        <li>Function Declarations não são <b>executable statements</b>, não é comum terminá-los com <code class="inlineCodeTag">;</code></li>
                        <p>Exemplo:
                    </ul>
                        <pre class="preTag px-4 fs-6">
                            <code>
function functionName(parâmetros) {
    ...
} //Sem uso de ;
                            </code>
                        </pre>
                    <br><hr>
                </div>
                <div class="px-5 py-3">
                    <h2 class="pb-4">Function <b class="red">Expression</b></h2>
                    <ul>
                        <li>Uma function expression pode ser <b>armazenada</b> em uma <b>variável</b>;</li> 
                        <li>A variável poderá ser <b>usada</b> como uma <b>função</b>;</li>
                            <ul>
                                <li>A variável será usada para <b>invocar a função</b>;</li>
                                <li>Por causa disso, a função não precisará de um nome para identificá-la;</li>
                                <li>Uma função que não tem nome é chamada de <b>função anônima</b></li> 
                            </ul>
                        </li>
                        <li>Function Expressions terminam com <code class="inlineCodeTag">;</code> pois fazem parte de um "executable statement". (instrução executável)</li> 
                        <li>Uma function expression sempre terá um <b>valor constante</b>.</li>
                            <ul><li>Portanto, usar "const" é mais seguro do que usar "var"</li></ul>
                        <p>Exemplo:</p>
                    </ul>
                        <pre class="preTag px-4 fs-6">
                            <code>
const a = function (x, y) {return x * y};
let b = a(4, 3);
                            </code>
                        </pre>
                    <h3>Self-Invoking Functions</h3>
                    <ul>
                        <li>Uma <b>Self Invoking Function</b> é <b>INVOCADA AUTOMATICAMENTE</b>, sem ser chamada.</li>
                        <li><b>APENAS</b> <b class="red">Function Expressions</b> podem ser invocadas automaticamente</li>
                        <li><b class="red">Function Declarations</b> <b>NÃO PODEM</b> ser invocadas automaticamente</li>
                        <li>Precisa-se adicionar parênteses em volta da função para indicar que é uma "function expression"</li>
                        <li>A função deve ser seguida de parênteses</li>
                    </ul>
                    <p>Exemplo: Anonymous Self-invoking Function </p>
                    <pre class="preTag px-4 fs-6">
                        <code>
<b>(</b>function () {
    let x = "Hello World !";
}<b>)()</b>;

//Note os parênteses envolvendo a função
//Note os parênteses '()' após a função
                        </code>
                    </pre>

                    <h3>Funções Anônimas</h3>
                    <ul>
                        <li>São as funções que <b>não possuem nome</b>;</li>
                        <li>Funções armazenadas em variáveis não precisam de nomes
                            <ul><li>Serão sempre invocadas usando o próprio nome da variável.</li></ul>
                        </li>
                    </ul>
        


                    <h3>Arrow Functions</h3>
                    <ul>
                        <li>Permitem uma sintaxe menor para escrever "function expressions" </li>
                        <li>Não são necessários as palavras-chave FUNCTION, RETURN e as CHAVES </li>
                    </ul>
                    Exemplo: <b>Declaração Comum</b>
                    <pre class="preTag px-4 fs-6">
                        <code>
var x = function(x, y) {
    return x * y;
}
                        </code>
                    </pre>
                    Exemplo: <b>Arrow Function</b>
                    <pre class="preTag px-4 fs-6">
                        <code>
const x = (x, y) => x * y;
                        </code>
                    </pre>
                    <ul>
                        <li>Arrow functions:</li>
                        <ul>
                            <li>Não têm <b>this</b>;</li>
                            <li>Não são adequadas para definir <b>métodos de um objeto</b>;</li>
                            <li>NOT HOISTED: <b>devem ser definidas antes de serem usadas</b>.</li>
                        </ul>   
                        <li>Quando a função for <b>single statement</b> ( tiver uma única instrução):
                             <ul>
                                <li>A palavra-chave <code class="inlineCodeTag">return</code> e <code class="inlineCodeTag">{ }</code> podem ser omitidas</li>
                                <li>É uma boa prática usá-las sempre</li>
                            </ul>
                        </li>
                    </ul>
                    Exemplo:
                    <pre class="preTag px-4 fs-6">
                        <code>
//return e { } omitidos
const x = (x, y) => x * y;

//Recomendado
const x = (x, y) => { return x * y };
                        </code>
                    </pre>     
                </div>
            </div>
        </div>

        <div class="container-xxl">
            <div class="bd-content">
                <div class="boundingLines"></div>
                <h1 class="px-4"><mark class="lineText">Function() Contructor</mark></h1>
                <div class="px-4 py-3">

                    <ul>
                        <li>Funções também podem ser definidas com o construtor <code class="inlineCodeTag">Function()</code> </li>
                        <li> O uso desse construtor é <b>opcional</b></li>
                    </ul>
                    Exemplo:
                    <pre class="preTag">
                        <code>
    const myFunction = new Function("a", "b", "return a * b");
    let x = myFunction(4, 3);
                        </code>
                    </pre>
        
                    Exemplo:
                    <pre class="preTag">
                        <code>
    const myFunction = function (a, b) {return a * b};
    let x = myFunction(4, 3);
                        </code>
                    </pre>
                </div>

            </div>
        </div>

        <div class="container-xxl">
            <div class="bd-content">
                <h1 class="px-4 mb-5"><mark class="lineText">Bizu</mark></h1>
                <div class="boundingLines"></div>
                <div class="px-4">
                    <ul class="px-5">
                        <li>Funções podem ser usadas como <b>valores</b> e também <b>em expressões</b>.</li>
                        <li>Exemplo como <b>valor</b>:</li>
                    </ul>
                    <div class="px-5">
                    <pre class="preTag ps-4 fs-6">
                        <code>
function myFunction(a, b) {
    return a * b;
}
let x = <b>myFunction(4, 3)</b>;	
console.log(x);

//Usada como valor
//Resposta 12 no console</code>
                    </pre>

                    <ul>
                        <li>Exemplo em uma <b>expressão</b>:</li>
                    </ul>
                    <pre class="preTag ps-4 fs-6">
                        <code>
function myFunction(a, b) {
    return a * b;
}
let x = <b>myFunction(4, 3)</b> * 2;	
console.log(x);		

//Usada como valor em uma expressão
//Resultado 24 no console</code>
                    </pre>
                </div>
                </div>
            </div>
        </div>

        <div class="container-xxl">
            <div class="bd-content">
                <div class="boundingLines"></div>
                <h1 class="px-4 mb-5"><mark class="lineText">Function Parameters / Function Arguments</mark></h1>
                <div class="px-5">
                    <!-- FUNCTION PARAMETERS -->
                    <div class="subHeader">
                        <h2><mark class="lineText">Function <b class="blue">Parameters</mark></b></h2>
                        <div class="solidLine"></div>
                    </div>
                    <div class="px-5">
                        <p>Exemplo:</p>
                        <pre class="preTag px-4 fs-6">
                            <code>
function functionName(<b>parameter1, parameter2, parameter3</b>){
    ...
}
                            </code>
                        </pre>
                        <ul>
                            <li>São os <b>nomes</b> listados na <b class="red">declaração da função</b></li>
                            <li>JavaScript function definitions do not specify data types for parameters.</li>
                            <li>As Funções JavaScript:
                                <ul>
                                    <li>Não verificam o <b class="red">tipo</b> <b>dos argumentos</b> passados.</li>
                                    <li>Não verificam o <b class="red">número</b> <b>de argumentos</b> recebidos.</li>
                                </ul>
                            </li>
                        </ul>
                        <h3>Default Parameter</h3>
                        <ul>
                            <li>Uma função pode ser chamada com <b>argumentos faltando</b> (menos do que foram declarados).</li>
                                <ul>
                                    <li>Os valores ausentes serão considerados como <code class="inlineCodeTag">undefined</code>;</li>
                                    <li>Existem casos em que isso pode ser aceitável;</li>
                                    <li>Contudo, no geral se <b>atribui</b> um valor <b>default</b> (predefinido) ao parameter.</li>
                                </ul>
                            </li>
                            <li>Exemplo:</li>
                        </ul>
                        <pre class="preTag px-4 fs-6">
                            <code>
function <b>myFunction(x, y)</b> {
if (y === undefined) { //Atribui o valor 2 como default a 'y', quando este for 'undefined'
y = 2;
}
return x * y;
}
console.log( <b>myFunction(4)</b> );

//Função possui 2 parameters mas é invocada com apenas 1 parameter
//Resultado 8 no console
                            </code>
                        </pre>
                    </div><br>

                    <!-- FUNCTION ARGUMENTS -->
                    <div class="subHeader">
                        <h2 class="my-4"><mark class="lineText">Function <b class="blue">Arguments</b></mark></h2>
                        <div class="solidLine"></div>
                    </div>
                    <div class="px-5">
                        <ul>
                            <li>São os <b>valores verdadeiros</b>;</li>
                            <li>São os valores que realmente são <b>passados</b> e <b>recebidos</b> pela função.</li>
                        </ul>
                        <h3 class="my-5">O <code class="inlineCodeTag">Arguments</code> Object</h3>
                        <ul>
                            <li><code class="inlineCodeTag">arguments</code> é um <b>Object</b>, muito semelhante a um <b>array</b>.
                                <ul>
                                    <li>É um object interno das funções do Javascript;</li>
                                    <li>Ele pode ser acessado dentro das funções;</li>
                                    <li>Ele contêm os valores dos arguments passados para a função.</li>
                                    <li>Uma função pode ser invocada com mais arguments do que foram declarados inicialmente</li>
                                        <ul><li>Esses arguments "a mais" podem ser alcançados com o <code class="inlineCodeTag">arguments</code> object" </li></ul>
                                </ul>
                            </li>
                            <li>Exemplo:</li>
                        </ul>
                        <pre class="preTag px-4 fs-6">
                            <code>
function func1(a, b, c) {
    console.log(<b>arguments[0]</b>);
    // output esperado: 1
    
    console.log(<b>arguments[1]</b>);
    // output esperado: 2
    
    console.log(<b>arguments[2]</b>);
    // output esperado: 3
}
    
func1(1, 2, 3);
                            </code>
                        </pre>
                        <ul>
                            <li>
                                Os <code class="inlineCodeTag">Arguments</code> são passados por <b>valor</b>
                                <ul>
                                    <li>Quando uma função for chamada, os parameters serão os argument dela </li>
                                    <li>Os JavaScript Arguments são passados por valor: a função só conhece os valores e não a localização dos arguments.</li>    
                                    <li>Quando uma função altera o valor de um argument o valor original do parameter NÃO é alterado;</li> 
                                    <li>Alterações nos arguments <b>NÃO SÃO VISÍVEIS FORA</b> da função.</b></li> 
                                    </li>
                                </ul>
                            </li>
                        </ul>
                        <ul>
                            <li>
                                Os <code class="inlineCodeTag">Objects</code> são passados por <b>referência</b>
                                <ul>
                                    <li>No javascript, <b>Object References</b> são valores, por causa disso, Objects vão se comportar como se fossem passados por referência</li>
                                    <li>Se uma função altera o valor de uma propriedade do object, ela também vai alterar o valor original</li>
                                    <li>Alterações nas propriedades do object <b>SÃO VISÍVEIS FORA</b> da função.</b>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <div class="container-xxl">
            <div class="bd-content">
                <div class="boundingLines"></div>
                <h1 class="px-4"><mark class="lineText">Palavra-chave <b class="gold">this</b></mark></h1>
                <div class="px-5">
                    <ul>
                        <li>No JavaScript todas as funções são métodos, que pertencem a algum objeto</li>
                        <li>As funções que não pertencem a um objeto específico, pertencem ao objeto global (global object)</li>    
                    </ul>
                    <ul>
                        <li>Nesse sentido, <code class="inlineCodeTag">this</code> se refere ao <b>"dono"</b> dessa função, ou seja, o objeto que é o <b>proprietário</b> da função.
                        <li>Propriedades do <code class="inlineCodeTag">this</code>:
                            <ul>
                                <li>Quando usado em uma função, representa o <b>object</b> que <b>possui</b> essa função;</li>
                                <li>É uma palavra-chave, a qual <b>não</b> pode ter o seu <b>valor alterado</b>;</li>
                                <li><b>Não</b> é uma variável.</li>
                            </ul>
                        </li>
                        <li>When a function is called without an owner object, the value of "this" becomes the global object.</li>
                        <li>Em um navegador da web, o global object é a <b>janela do browser</b>.</li>
                    </ul>
                    <p>Exemplo</p>
                    <pre class="preTag px-4 fs-6">
                        <code>
let x = myFunction();
function myFunction() {
    return <b>this</b>;
}
console.log(x); 

//Será retornado <b>[object Window]</b>
                        </code>
                    </pre>
                    <ul>
                        <li>Invocar uma função como uma <b>global function</b> faz com que o valor de <code class="inlineCodeTag">this</code> seja o <b class="red">global object</b>. </li>
                        <li>Usar o <code class="inlineCodeTag">window object</code> como uma variável pode facilmente travar o seu programa.</li>
                    </ul>
                </div>
            </div>
        </div>





        <h1>INVOCAÇÃO DE FUNÇÕES JAVASCRIPT</h1>
        <p>
            O código dentro de uma função não é executado quando a função é definida, mas sim quando a função é invocada. <br>
            É comum usar o termo "chamar uma função (call a function)" em vez de "invocar uma função (invoke a function)". <br>
            Será usado o termo invocar, pois uma função JavaScript pode ser invocada sem ser chamada. <br>

            ex: <br>
            &#60body> <br>
                &#60script> <br>
                    function myFunction(a, b) { <br>
                    return a * b; <br>
                    } <br>
                    var x = myFunction(10, 2)		 <br>
                    var y = window.myFunction(10, 2)	//"x" e "y" recebem o mesmo valor <br>
                    console.log(x); 	<br>
                    console.log(y);<br>
                &#60/script><br>
            &#60/body><br>


            A função acima não pertence a nenhum objeto. Mas em JavaScript SEMPRE HAVERÁ como padrão o "global object" <br>
            O "global object" padrão é a própria página HTML, portanto, a função acima pertence à página HTML.<br>
            In a browser the page object is the browser window. The function above automatically becomes a window function. <br>
            myFunction() e window.myFunction() são a mesma função <br>
        </p>

        <h2>INVOCANDO UMA FUNÇÃO COMO UM MÉTODO</h2>
        <p>
            • No JavaScript você pode definir funções como sendo métodos de um objeto. <br>
            • ex: Criar um objeto (myObject), com duas propriedades(firstName e lastName) e um método(fullName) <br>
                const myObject = { <br>
                firstName:"John", <br>
                lastName: "Doe", <br>
                fullName: function() { <br>
                    return this.firstName + " " + this.lastName;<br>
                } <br>
                } <br>
                var x = myObject.fullName(); <br>
                console.log(x);		//John Doe <br>

            • O método fullName é uma função. A função pertence ao objeto "myObject", que é o "proprietário" da função.	 <br> 
            • A palavra-chave this se refere ao objeto que "possui" o código, nesse caso, o valor de this será "myObject" <br>
            • Invocar uma função como um método de um objeto faz com que o valor da palavra-chave "this" seja o próprio objeto onde a função foi invocada. <br>
        </p>

        <h2>INVOCANDO UMA FUNÇÃO COM UM "FUNCTION CONSTRUCTOR"</h2>
        <p>
            • Quando uma função for invocada e for precedida pela palavra "new", essa será uma "constructor invocation" <br>
            • Funções Javascript são objetos, então, mesmo que pareca que uma nova função está sendo criada, na realidade é um objeto que está sendo criado <br>
            • Uma invocação do construtor (constructor invocation) cria um novo objeto, esse novo objeto herda as propriedades e métodos do seu construtor. <br>
            • A palavra-chave "this" no construtor não possui um valor. <br>
            • O valor de "this" será o novo objeto criado quando a função for chamada. <br>
        </p>

        <h1>MÉTODO "CALL()"</h1>
        <p>
            O método call() é um método predefinido pelo Javascript <br>
            
            O método call() pode ser usado para invocar uma função(método), com um "owner object" sendo usado como argumento (parâmetro). <br>
            Com o call(), um objeto pode usar métodos pertencentes a outro objeto <br>
            ex: <br> 
                const person = { <br>
                fullName: function() { <br>
                    return this.firstName + " " + this.lastName; <br>
                } <br>
                } <br>

                const person1 = { <br>
                firstName:"John", <br>
                lastName: "Doe" <br>
                } <br>
                const person2 = { <br>
                firstName:"Mary", <br>
                lastName: "Doe" <br>
                } <br>
                var x = person.fullName.call(person1); <br>
                console.log(x); <br>
            

            O método call() aceita argumentos <br>
            ex: <br>
                const person = { <br>
                fullName: function(city, country) { <br>
                    return this.firstName + " " + this.lastName + "," + city + "," + country; <br>
                } <br>
                } <br>

                const person1 = { <br>
                firstName:"John", <br>
                lastName: "Doe" <br>
                } <br>

                const person2 = { <br>
                firstName:"Mary", <br>
                lastName: "Doe" <br>
                } <br>
                var x = person.fullName.call(person1, "Contagem", "Brasil"); 		//Argumentos <br>
                console.log(x)						// John Doe, Contagem, Brasil <br>
        </p>
	
        <h1>Método Apply()</h1>
        <p>
            O método apply() é similar ao método call() <br>
            A grande diferença está no fato de que: <br>
                ∟O método call() aceita os argumentos SEPARADAMENTE; <br>
                ∟O método apply() aceita os argumentos como um ARRAY <br>


            ex: método call() <br>
                const person = { <br>
                fullName: function(city, country) { <br>
                    return this.firstName + "," + city + "," + country; <br>
                } <br>
                } <br>
                const person1 = { <br>
                firstName:"João", <br>
                lastName: "Machado" <br>
                } <br>
                document.getElementById("demo").innerHTML = person.fullName.apply(person1, "Contagem", "Brasil"); 	//Argumentos separados <br>

            ex: método apply() <br>
                const person = { <br>
                fullName: function(city, country) { <br>
                    return this.firstName + "," + city + "," + country; <br>
                } <br>
                } <br>
                const person1 = { <br>
                firstName:"João", <br>
                lastName: "Machado" <br>
                } <br>
                document.getElementById("demo").innerHTML = person.fullName.apply(person1, ["Contagem", "Brasil"]); 	//Argumento em array <br>


            <h2>Simular o método max() em arrays</h2>
                Você pode encontrar o maior número em uma lista de números usando o método Math.max(): <br>
                Os arrays JavaScript não têm um método max() <br>
                ex: <br>
                    document.getElementById("demo").innerHTML = Math.max.apply(null, [1,2,3]); 	→Irá retornar 3  <br>

                O primeiro argumento (null) não importa, ja que não é usado nesse caso. <br>
                    ∟Também pode ser escrito como <br>
                            Math.max.apply(Math, [1,2,3]); <br>
                                Math.max.apply(" ", [1,2,3]); <br>
                            Math.max.apply(0, [1,2,3]); <br> 


            <h2>JAVASCRIPT STRICT MODE</h2>
                No "strict mode", se o primeiro argumento do método apply() não for um objeto, o método apply() se tornará o proprietário (objeto) da função invocada.<br>
                No "non-strict" mode o global object se torna o proprietário da função <br>
        </p>   
        
        <h1>Escopo e Function CLOSURES</h1>
        <p>
            Uma função pode acessar todas as variáveis definidas dentro dela mesma <br>
                ∟Exemplo <br>
                    function myFunction () { <br>
                    let a = 4;		//Nesse caso "a" é uma variável local <br>
                    return a * a; <br>
                    } <br>

            Uma função também pode acessar variáveis definidas fora da função: <br>
                ∟Exemplo <br>
                    let a = 4;			//Nesse caso "a" é uma variável global <br>
                    function myFunction () { <br>
                    return a * a; <br>
                    } <br>

            • <b>Variável Global</b>: São acessíveis a todos os escopos <br>
                ∟Variáveis globais podem ser feitas locais (privadas) com closures. <br>
                ∟Variáveis criadas sem palavra-chave (var, let ou const) são sempre globais, mesmo se forem criadas dentro de uma função. <br>
                    Exemplo <br>
                    function myFunction() { <br>
                    a = 4;			→Será considerada uma variável global <br>
                    } <br>
            • <b>Variável Local</b>: Uma variável local só pode ser usada dentro da função onde está definida. <br>

                *Variáveis globais e locais com o mesmo nome são consideradas como variáveis diferentes. Modificar um não altera a outra. <br>

            <h2>Tempo de vida das variáveis</h2>
                ∟Variáveis globais são descartadas assim que você navega para outra página ou fecha a janela. <br>
                ∟Variáveis locais são criadas quando a função é chamada e descartadas quando a função é concluída. <br>


            <h2>Um problema do Contador</h2>
                • Suponha que você queira usar uma variável para contar algo e que esse contador esteja disponível para todas as funções do programa <br>
                
                Você pode usar uma variável global e uma função para aumentar o contador <br>
                ex: 1.jpg <br>
                O problema com essa solução é que qualquer código na página pode alterar o contador, sem chamar o add(). <br>

                O contador deve ser local para a função add (), para prevenir que outros códigos o altere: <br>
                ex: 2.jpg <br>
                Não funcionou porque exibimos o contador global em vez do contador local. <br>

                Podemos remover o contador global e acessar o contador local, permitindo que a função o retorne: <br>
                ex: 3.jpg <br>
                Não funcionou porque zeramos o contador local toda vez que chamamos a função. <br>
            
                Uma função interna do JavaScript pode resolver isso (Inner Function) <br>


            <h2>NESTED FUNCTIONS</h2>
            <p>
                • Todas as funções têm acesso ao escopo global. <br>
                • Na verdade, no JavaScript, todas as funções têm acesso ao escopo "acima" delas. <br>
                • O JavaScript oferece suporte a nested functions (funções aninhadas). <br>
                • As funções aninhadas têm acesso ao escopo "acima" delas. <br>
                Exemplo: 'a função interna plus() tem acesso a variável do contador na parent function' <br>

                document.getElementById("demo").innerHTML = add(); <br>
                function add() { <br>
                let counter = 0; <br>
                function plus() {counter += 1;} <br>
                plus();   <br>
                return counter;  <br>
                } <br>

                • Isso poderia ter resolvido o problema do contador, se pudéssemos alcançar a função plus() de fora. <br>
                • Também precisamos encontrar uma maneira de executar o counter = 0 apenas uma vez. <br>
                • Para isso será necessário uma "closure" <br>

            <h2>JAVASCRIPT CLOSURES</h2>
                ex: <br>
                    &#60body> <br>
                    &#60button type="button" onclick="myFunction()">Count!&#60/button> <br>
                    &#60p id="demo">0&#60/p> <br>
                    &#60script> <br>
                        const add = (function () { <br>
                        let counter = 0; <br>
                        return function () {counter += 1; return counter;} <br>
                        })(); <br>

                        function myFunction(){ <br>
                        document.getElementById("demo").innerHTML = add(); <br>
                        } <br>
                    &#60/script> <br>
                    &#60/body> <br>

                A variável add() é atribuída ao valor de retorno de uma self-invoking function. <br>
                A self-invoking function é executada apenas uma vez. Ela define o contador para zero 0 e retorna uma function expression. <br>
                Desta forma, "add" torna-se uma função. O benefício é que ela pode acessar o contador no parent scope. <br>
                Isso é chamado de javascript enclosure, e torna possível que uma função tenha variáveis "privadas". <br> 
                O contador é protegido pelo escopo da função anônima e só pode ser alterado usando-se a função add. <br>

    </body>
</html>
