<!DOCTYPE html>
<html lang='en'>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta charset="UTF-8">
        <title>Funções Javascript</title>

        <!-- Bootstrap CSS -->
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
        
        <!-- myGlobalCSS -->
        <link rel="stylesheet" type="text/css" href="https://thiago-meneses.github.io/myGlobalCSS.css">


        <!-- FONTS -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@200;300;400;600;700;800;900&display=swap" rel="stylesheet">

        <!-- FONTS -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Fira+Mono:wght@400;500;700&family=Fira+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,300&family=Roboto+Mono:wght@100;200;300;400;500;600;700&display=swap" rel="stylesheet">
    </head>
    <body>
        <div class="container-lg px-4">
            <h1 class="initialTitle">Funções em Javascript</h1>
            <p>
                Funções são definidas pela palavra-chave "function" <br>
                Funções são <b>objetos</b>
            </p>
            <hr>
        </div>

        <!-- PROPRIEDADES E METHODS -->
        <div class="container-lg">
            <div class="content oloko">
                <div class="boundingLines"></div>
                <div class="px-5 pb-3">
                    <h2><mark class="lineText">Propriedades e Methods de uma Function</mark></h2>
                    <div class="content">
                        <h3 class="px-2"><mark class="lineText"><b class="gold">Propriedades</b> de uma Function</mark></h3>
                        <div class="innerBoundingLines"></div>
                        <div class="px-5">
                            <p>
                                Functions possuem <b>propriedades</b>.<br>
                            </p>
                            <p class="mb-05em">
                                <b>Exemplo</b> com a propriedade <code class="inlineCode">.length</code>:
                            </p>
                            <pre class="px-4 preTag">
                                <code>
function myFunction(a, b) {
    return arguments<b>.length</b>;
}
console.log(myFunction(4, 3)); //Será retornado "2" no console    
                                </code>
                            </pre>
                        </div>
                        <br>
                    </div>
                    
                    <div class="content">
                        <h3 class="px-2"><mark class="lineText"><b class="gold">Methods</b> de uma Function</mark></h3>
                        <div class="innerBoundingLines"></div>
                        <div class="px-5">
                            <p>
                                Functions também possuem <b>methods</b>.
                            </p>
                            <p class="mb-05em">
                                <b>Exemplo</b> com o method <code class="inlineCode">.toString()</code>
                            </p>
                            <pre class="preTag px-4">
                                <code>
function myFunction(a, b) {
    return a * b;
}
console.log( myFunction<b>.toString()</b> );

//Retornado: "function myFunction(a, b) { return a * b; }"
                                </code>
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- FUNCTION DECLARATION VS FUNCTION EXPRESSION -->
        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4"><mark class="lineText">Declaration - Expression</mark></h2>
                <!-- FUNCTION DECLARATIONS -->
                <div class="px-5 py-3">
                    <div class="content">
                        <div class="innerBoundingLines"></div>
                        <h3 class="px-2"><mark class="lineText">Function <b class="gold">Declaration</b></mark></h3>
                        <div class="px-4">
                            <ul>
                                <li>É a forma mais familiar, normalmente com a qual se aprende a definir uma function pela primeira vez;</li>
                                <li>Também recebe o nome de <b class="red">Function Statement</b>;</li>
                                <li>Funções declaradas <b>NÃO</b> são <b>executadas imediatamente</b>;</li>
                                <li>Function Declarations são içadas <b class="red">"hoisted"</b> ;</li>
                                <li>São executadas apenas quando <b>invocadas</b>;</li>
                                <li>Function Declarations não são <b>executable statements</b>, não é comum terminá-los com <code class="inlineCode">;</code></li>
                            </ul>
                            <p class="mb-05em"><b>Exemplo:</b> Function Declaration</p>
                            <pre class="preTag px-4">
                                <code>
function functionName(parâmetros) {
    console.log("Hello world");
}

functionName(); //Invocando uma function declaration
                                </code>
                            </pre>
                        </div>
                    </div>
                </div>

                <!-- FUNCTION EXPRESSION -->
                <div class="px-5 py-3">
                    <div class="content">
                        <div class="innerBoundingLines"></div>
                        <h3 class="px-2"><mark class="lineText">Function <b class="gold">Expression</b></mark></h3>
                        <div class="px-4">
                            <ul>
                                <li>Uma function expression pode ser <b>armazenada</b> em uma <b>variável</b>;</li> 
                                <li>A variável em que a function for armazenada poderá ser <b>usada</b> como uma <b>function</b>;</li>
                                    <ul class="innerUl">
                                        <li>A variável será usada para <b>invocar a função</b>;</li>
                                        <li>Por causa disso, a função não precisará de um nome para identificá-la;</li>
                                        <li>Uma função que não tem nome é chamada de <b>Anonymous Function</b>.</li> 
                                    </ul>
                                </li>
                                <li>Function Expressions terminam com <code class="inlineCode">;</code> pois fazem parte de uma <b>instrução executável</b>: <b class="red">Executable Statement</b> ;</li> 
                                <li>Uma function expression sempre terá um <b class="red">valor constante</b> ;</li>
                                    <ul class="innerUl"><li>Portanto, usar <code class="inlineCode">const</code> é mais seguro do que usar <code class="inlineCode">var</code>.</li></ul>
                                <li>Function Expressions <b>não são içadas</b>: <b class="red">Not hoisted</b> ;
                                    <ul class="innerUl">
                                        <li>Apenas a variável que recebe a function expression é içada;</li>
                                        <li>A própria function não será içada.</li>
                                    </ul>
                                </li>
                            </ul>
                            <p class="mb-05em"><b>Exemplo</b> de uma Function Expression:</p>
                            <pre class="preTag px-4">
                                <code>
<b>const a = function (x, y) {return x * y};</b>
<span class="grey">let b = a(4, 3);</span>
                                </code>
                            </pre>

                            <p class="mb-05em"><b>Exemplo</b> de uma Function Expression com nome:</p>
                            <pre class="preTag px-4">
                                <code>
<span class="grey">//Qualquer nome pode ser dado para a function, mas recomenda-se usar o mesmo nome dado a variável, por organização
var</span> <b>nomeVar</b> <span class="grey">= function</span> <b>nomeFunction()</b><span class="grey">{
    console.log('Hello world');
}

//Modo recomendado
var </span><b>nomeVar</b><span class="grey"> = function </span><b>nomeVar()</b><span class="grey">{
    console.log('Hello world');
}</span>
                                </code>
                            </pre>
                            <div class="subHeader">
                                <div class="solidLine"></div>
                                <h4><mark class="lineText"><b class="blue">Self-Invoking Functions</b></mark></h4>
                            </div>
                            
                            <ul>
                                <li>São as functions <b>invocadas automaticamente</b>, sem precisar de serem chamadas;</li>
                                <li>Apenas <b class="red">Function Expressions</b> podem ser invocadas automaticamente;</li>
                                <li>Function Declarations <b>NÃO podem</b> ser invocadas automaticamente;</li>
                                <li>Adiciona-se <code class="inlineCode">( )</code> <b>em volta</b> da function e <b>após</b> ela, para indicá-la como uma <b>function expression</b>;</li>
                            </ul>
                            <p class="mb-05em"><b>Exemplo:</b> Anonymous Self-invoking Function </p>
                            <pre class="preTag px-4">
                                <code>
<span class="bold">(</span><span class="grey">function () {
    let x = "Hello World !";
}</span><b>)()</b>;
                                </code>
                            </pre>

                            <div class="subHeader">
                                <div class="solidLine"></div>
                                    <h4 class="px-4"><mark class="lineText"><b class="blue">Anonymous Functions</b></mark></h4>
                            </div>
                            <ul>
                                <li>São as functions que <b>não possuem nome</b>;</li>
                                <li>Functions que forem armazenadas em variáveis <b>NÃO</b> precisam de nomes
                                    <ul class="innerUl"><li>Poderão sempre ser invocadas usando o próprio nome da variável.</li></ul>
                                </li>
                            </ul>

                            <div class="subHeader">
                                <div class="solidLine"></div>
                                    <h4 class="px-4"><mark class="lineText"><b class="gold">Arrow Functions</b></mark></h4>
                            </div>

                            <ul>
                                <li>Arrow Functions <b>sempre</b> serão <b class="red">Function Expressions</b>
                                    <ul class="innerUl"><li>Arrow functions permitem uma sintaxe menor para escrever function expressions</li></ul>
                                </li>
                                <li>Arrow Functions <b>nunca</b> serão Function declarations;</li>
                                <li>Não são necessários os termos:
                                    <ul class="innerUl">
                                        <li><code class="inlineCode"><b>function</b></code></li>
                                        <li><code class="inlineCode"><b>return</b></code> - Quando a function não tiver mais de uma linha</li>
                                        <li><code class="inlineCode"><b>{ }</b></code> - Quando a function não ter mais de uma linha</li>
                                        <li><code class="inlineCode"><b>( )</b></code> - Quando só haja 1 parâmetro</li>
                                    </ul>
                                </li>
                            </ul>

                            <ul>
                                <li><b>Caracterísitcas:</b>
                                    <ul class="innerUl">
                                        <li><b>Não</b> possuem <b class="red">this</b> ;</li>
                                        <li><b>Não</b> são içadas: <b class="red">Not Hoisted</b> ;</li>
                                        <li><b>Não</b> são adequadas para definir <b>Object Methods</b>.</li>

                                    </ul>   
                                </li>
                            </ul>

                            <h5 class="px-3 mt-15em">Transformando declarações comuns em arrow functions</h5>
                            <ol>
                                <li class="mb-05em">A palavra-chave <code class="inlineCode">function</code> não é usada:</li>
                                <pre class="preTag px-4">
                                    <code>
let myVar = <span class="weak">function</span>(data) {
    return "Hello World" + data;
}
</code>
                                </pre>
                                <pre class="preTag px-4 mb-3em">
                                    <code>
let myVar = (data) {
    return "Hello World" + data;
}
                                    </code>
                                </pre>

                                <li class="mb-05em">Removendo <code class="inlineCode">{ }</code> e <code class="inlineCode">return</code>, apenas quando a function for <b>single statement</b>:</li>
                                <pre class="preTag px-4">
                                    <code>
let myVar = (data) <span class="weak">{ return </span> "Hello World" + data; <span class="weak">}</span>
                                    </code>
                                </pre>
                                <pre class="preTag px-4 mb-3em">
                                    <code>
let myVar = (data) "Hello World" + data;

//Mesmo opcionais é uma boa prática usá-los sempre
                                    </code>
                                </pre>

                                <li class="mb-05em">Adicionando a Arrow Function <code class="inlineCode">=></code></li>
                                <pre class="preTag px-4 mb-3em">
                                    <code>
let myVar = (data) => "Hello World" + data;
                                    </code>
                                </pre>

                                <li>Com um único parâmetro, os parênteses podem ser removidos</li>
                                <pre class="preTag px-4 mb-3em">
                                    <code>
let myVar = data => "Hello World" + data;
                                    </code>
                                </pre>
                            </ol>

                            <p class="mb-05em"><b>Exemplo 1:</b> Adicionando um valor aos elementos de um array</p>
                            <pre class="preTag px-4">
                                <code>
<span class="grey">let array = [1,2,3,4,5];

//Arrow Function
let array2 = array.map</span><span class="bold">(v => v + 2)</span><span class="grey">,

//Declaração comum
let array3 = array.map(</span><span class="bold">function(v) { return v + 2; }</span><span class="grey">);

console.log(array2); //[3,4,5,6,7]
console.log(array3); //[3,4,5,6,7]</span>
                                </code>
                            </pre>

                            <p class="mb-05em"><b>Exemplo 2:</b> Arrow Function com mais de uma linha e mais de um parâmetro:</p>
                            <pre class="preTag px-4">
                                <code>
let greeting = (time, name) => {
    if (time === "day") return "Morning " + name;
    if (time === "night") return "Evening " + name;
}

let greet = greeting("day", "Steve");
console.log(greet); // Morning Steve
                                </code>
                            </pre>
                        </div>
                    </div>     
                </div>
            </div>
        </div>

        <!-- FUNCTION CONSTRUCTOR -->
        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4"><mark class="lineText">Function( ) <b class="gold">Contructor</b></mark></h2>
                <div class="px-4">
                    <ul>
                        <li>Functions também podem ser definidas usando o construtor <code class="inlineCode">Function()</code> </li>
                        <li> O uso desse construtor é <b>opcional</b></li>
                    </ul>
                    Exemplo:
                    <pre class="preTag px-4">
                        <code>
const myFunction = new Function("a", "b", "return a * b");
let x = myFunction(4, 3);
                        </code>
                    </pre>
        
                    Exemplo:
                    <pre class="preTag px-4">
                        <code>
const myFunction = function (a, b) {return a * b};
let x = myFunction(4, 3);
                        </code>
                    </pre>
                </div>

            </div>
        </div>

        <!-- Bizu -->
        <div class="container-lg">
            <div class="content">
                <h2 class="px-4 mb-5"><mark class="lineText"><b class="red">Bizu</b></mark></h2>
                <div class="boundingLines"></div>
                <div class="px-4">
                    <ul class="px-5">
                        <li>Funções podem ser usadas como <b>valores</b> e também <b>em expressões</b>.</li>
                        <li>Exemplo como <b>valor</b>:</li>
                    </ul>
                    <div class="px-5">
                    <pre class="preTag ps-4">
                        <code>
function myFunction(a, b) {
    return a * b;
}
let x = <b>myFunction(4, 3)</b>;	
console.log(x);

//Usada como valor
//Resposta 12 no console</code>
                    </pre>

                    <ul>
                        <li>Exemplo em uma <b>expressão</b>:</li>
                    </ul>
                    <pre class="preTag ps-4">
                        <code>
function myFunction(a, b) {
    return a * b;
}
let x = <b>myFunction(4, 3)</b> * 2;	
console.log(x);		

//Usada como valor em uma expressão
//Resultado 24 no console</code>
                    </pre>
                </div>
                </div>
            </div>
        </div>

        <!-- FUNCTION PARAMETERS / FUNCTION ARGUMENTS -->
        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4 mb-5"><mark class="lineText">Function Parameters / Function Arguments</mark></h2>
                <div class="px-5">
                    <!-- FUNCTION PARAMETERS -->
                    <div class="subHeader">
                        <h3><mark class="lineText">Function <b class="blue">Parameters</mark></b></h3>
                        <div class="solidLine"></div>
                    </div>
                    <div class="px-5">
                        <ul>
                            <li>São os <b>nomes</b> listados na <b class="red">declaração da função</b> ;</li>
                            <li>As definições das Functions do JavaScript não especificam os tipos de dados para parâmetros;</li>
                            <li>As Funções JavaScript:
                                <ul class="innerUl">
                                    <li><b>Não</b> verificam o <b class="red">tipo</b> <b>dos argumentos</b> passados.</li>
                                    <li><b>Não</b> verificam o <b class="red">número</b> <b>de argumentos</b> recebidos.</li>
                                </ul>
                            </li>
                        </ul>
                        <p class="mb-05em"><b>Exemplo:</b></p>
                        <pre class="preTag px-4">
                            <code>
<span class="grey">function functionName(</span><b>parameter1, parameter2, parameter3</b><span class="grey">){
    ...
}</span>
                            </code>
                        </pre>
                        <h4>Default Parameter</h4>
                        <ul>
                            <li>Uma função pode ser chamada mesmo que haja <b>argumentos faltando</b> (menos do que foram declarados).</li>
                                <ul class="innerUl">
                                    <li>Os valores ausentes serão considerados como <code class="inlineCode">undefined</code>;</li>
                                    <li>Existem casos em que isso pode ser aceitável;</li>
                                    <li>No geral, é atribuído um <b>valor default</b> ( predefinido ) ao parâmetro.</li>
                                </ul>
                            </li>
                        </ul>
                        <p class="mb-05em"><b>Exemplo:</b> Atribuindo um valor default para um parâmetro</p>
                        <pre class="preTag px-4">
                            <code>
function <b>myFunction(x, y)</b> {
    if (y === undefined) { //Atribui o valor 2 como default para <b>y</b>, quando este for 'undefined'
        y = 2;
    }
    return x * y;
}
console.log( <b>myFunction(4)</b> );

//A function possui 2 parâmetros mas é invocada com apenas 1
//Console: 8
                            </code>
                        </pre>
                    </div><br>

                    <!-- FUNCTION ARGUMENTS -->
                    <div class="subHeader">
                        <h3 class="my-4"><mark class="lineText">Function <b class="blue">Arguments</b></mark></h3>
                        <div class="solidLine"></div>
                    </div>
                    <div class="px-5">
                        <ul>
                            <li>São os valores que realmente são <b>passados</b> e <b>recebidos</b> pela função.</li>
                            <li>São os <b>valores verdadeiros</b>;</li>
                        </ul>
                        <h4 class="my-5">O <code class="inlineCode">Arguments</code> Object</h4>
                        <ul>
                            <li><code class="inlineCode">arguments</code> é um <b>Object</b>, muito semelhante a um <b>array</b>.
                                <ul class="innerUl">
                                    <li>É um <b>object interno</b> das functions do Javascript;</li>
                                    <li>Pode ser acessado <b>dentro</b> das functions;</li>
                                    <li><b>Contêm</b> os <b>valores dos arguments</b> que foram passados para a function;</li>
                                    <li>Uma function pode ser invocada com mais arguments do que foram declarados inicialmente;</li>
                                        <ul><li>Esses arguments adicionais podem ser alcançados com o <code class="inlineCode">arguments</code> object.</li></ul>
                                </ul>
                            </li>
                            
                        </ul>
                        <p class="mb-05em"><b>Exemplo:</b></p>
                        <pre class="preTag px-4">
                            <code>
function exampleFunction(a, b, c) {
    console.log(<b>arguments[0]</b>);
    // output: 1
    
    console.log(<b>arguments[1]</b>);
    // output: 2
    
    console.log(<b>arguments[2]</b>);
    // output: 3
}
    
exampleFunction(1, 2, 3);
                            </code>
                        </pre>

                        <p class="mb-05em"><b>Exemplo 2:</b> Alcançando um argumento que não foi declarado inicialmente</p>
                        <pre class="preTag px-4">
                            <code>
function exampleFunction(a, b, c) {
    console.log(<b>arguments[0]</b>);
    // output: 1
    
    console.log(<b>arguments[1]</b>);
    // output: 2
    
    console.log(<b>arguments[2]</b>);
    // output: 3

    console.log(<b>arguments[3]</b>);
    // output: 4
    // Não foi declarado mas mesmo assim obtemos o valor
}
    
exampleFunction(1, 2, 3, 4);
                            </code>
                        </pre>
                        <script src="app.js"></script>
                        <ul>
                            <li>
                                Os <code class="inlineCode">Arguments</code> são <b>passados por <span class="red">valor</span> :</b>
                                <ul class="innerUl">
                                    <li>Quando uma function for chamada, os parâmetros serão os arguments dela;</li>
                                    <li>Os arguments do JavaScript são <b>passados por valor</b>;</li>
                                    <li>A function só conhece os <b>valores</b> e não a localização dos arguments;</li>    
                                    <li>Se uma function altera o valor de um argument, o <b>valor original</b> do parâmetro <b>NÃO</b> é alterado;</li> 
                                    <li>Alterações nos <b>arguments NÃO</b> são visíveis <b>fora da function.</b></li> 
                                    </li>
                                </ul>
                            </li>
                        </ul>
                        <ul>
                            <li>
                                Os <code class="inlineCode">Objects</code> são <b>passados por <span class="red">referência</span> :</b>
                                <ul class="innerUl">
                                    <li>No javascript, <b>Object References</b> são <b>valores</b>, e por causa disso, <b>objects</b> vão se comportar como se fossem passados por <b>referência</b>;</li>
                                    <li>Se uma function altera o valor de uma propriedade do object, o valor original <b>também</b> será alterado;</li>
                                    <li>Alterações nas <b>propriedades</b> do object <b>SÃO</b> visíveis <b>fora da function</b>.</b>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- THIS KEYWORD -->
        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4"><mark class="lineText">Palavra-chave <b class="gold">this</b></mark></h2>
                <div class="px-5">
                    <ul>
                        <li>No JavaScript todas <b>functions</b> são <b>métodos</b>, que <b>pertencem a algum objeto</b>.</li>
                        <ul class="innerUl"><li>As functions que não pertencem a um objeto específico, pertencem ao <b class="red">Global Object</b> ( Objeto Global ).</li></ul>
                    </ul>
                    <ul>
                        <li>Nesse contexto, a palavra-chave <code class="inlineCode">this</code> se refere ao <b>dono</b> dessa function, ou seja, o <b>object</b> que é o <b class="red">proprietário</b> da function.
                        <li><b>Propriedades</b> do <code class="inlineCode">this</code>:
                            <ul class="innerUl">
                                <li>Quando usado dentro de uma function, representa o <b>object</b> que <b>possui</b> a própria function;</li>
                                <li>O seu valor <b>NÃO PODE</b> ser <b>alterado</b>;</li>
                                <li><b>NÃO</b> é uma <b>variável</b>.</li>
                            </ul>
                        </li>
                        <li>Quando uma function é invocada sem um object que seja seu proprietário (dono), o valor do <b>this</b> se torna o <b class="red">global object</b>.</li>
                        <li>Em um navegador da web, o <b>global object</b> é a <b class="red">janela do browser</b>.</li>
                    </ul>
                    <p class="mb-05em"><b>Exemplo:</b></p>
                    <pre class="preTag px-4">
                        <code>
<span class="grey">let x = myFunction();
function myFunction() {
    return </span><b>this</b><span class="grey">;
}
console.log(x); 

//Será retornado </span><b>[object Window]</b>
                        </code>
                    </pre>
                    <ul><li>Invocar uma função como uma <b>global function</b> faz com que o valor de <code class="inlineCode">this</code> seja o <b class="red">global object</b>. </li></ul>
                </div>
            </div>
        </div>

        <!-- EVOKING FUNCTIONS IN JAVASCRIPT -->
        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4"><mark class="lineText">Invocação de Functions no Javascript</mark></h2>
                <div class="px-5">
                    <ul>
                        <li>O código dentro de uma função não é executado quando a função é definida, mas sim quando a função é <b>invocada</b>. </li>
                        <li>É comum usar o termo <b>Call a function</b> (Chamar uma function) ao invés de <b>Invoke a function</b> (Invocar uma function). </li>
                        <ul class="innerUl"><li>Será usado o termo <b>invocar</b>, pois uma função pode ser <b>invocada SEM ser chamada</b>. </li></ul>
                    </ul>
                    <p class="mb-05em"><b>Exemplo:</b></p>
                    <pre class="preTag px-4">
                        <code>
function myFunction(a, b) { 
    return a * b; 
} 

var x = myFunction(10, 2)		 
var y = window.myFunction(10, 2)
//<b>x</b> e <b>y</b> recebem o mesmo valor

console.log(x); 	
console.log(y);
                        </code>
                    </pre>
                    <ul>
                        <li>A função acima não pertence a nenhum object</li>
                            <ul class="innerUl">
                                <li>Contudo, em JavaScript, <b>sempre haverá</b> o object padrão <b class="gold">global object</b> ;</li>
                                <li>O <b>global object</b> é a própria <b>página HTML</b>, portanto, a function acima <b>pertence</b> à <b>página HTML</b>.</li>
                            </ul>
                        <li>Em um browser, o <b>page object</b> é a própria janela do browser. A function acima se torna automaticamente uma <b>window function</b>.</li>
                        <li><code class="inlineCode">myFunction()</code>  e <code class="inlineCode">window.myFunction()</code> são a mesma function;</li>
                        <li>Usar o <code class="inlineCode">window object</code> como uma variável pode facilmente travar o seu programa.</li>
                    </ul>
            
                    <div class="subHeader">
                        <h3 class="mt-5 mb-4"><mark class="lineText">Invocando Functions como um <b class="blue">Method</b></mark></h3>
                        <div class="solidLine"></div>
                    </div>
                    <ul><li>No JavaScript, functions podem ser definidas como sendo <b>Methods</b> de um object. </li></ul>
                    <p class="mb-05em"><b>Exemplo:</b> Criar um <b>object</b> com as propriedades <code class="inlineCode">firstName</code>, <code class="inlineCode">lastName</code> e um method <code class="inlineCode">fullName</code>:</p>
                    <pre class="preTag px-4">
                        <code>
<span class="grey">const myObject = { 
    </span><b>firstName</b><span class="grey">:"John", 
    </span><b>lastName</b><span class="grey">: "Doe", 
    </span><b>fullName</b><span class="grey">: function() { 
        return this.firstName + " " + this.lastName;
    } 
} 
var x = myObject</span><b>.fullName()</b><span class="grey">; 
console.log(x); //John Doe </span>
                        </code>
                    </pre>
                    <ul>
                        <li>O method <code class="inlineCode">fullName</code> é uma <b>function</b>.
                            <ul class="innerUl">
                                <li>A function pertence ao object <code class="inlineCode">myObject</code>;</li>
                                <li><code class="inlineCode">myObject</code> é o <b>proprietário</b> da function.</li>
                            </ul>
                        </li>
                        <li>A palavra-chave <b>this</b> se refere ao objec que <b>possui</b> o código
                            <ul class="innerUl"><li>Nesse caso, this terá o <b>valor</b> de <code class="inlineCode">myObject</code>.</li></ul>
                        </li>
                        <li>Invocar uma function como um <b>method</b> pertencente a um object faz com que o valor de <b>this</b> seja o próprio <b>object</b> onde a função foi invocada.</li>
                    </ul>
            
                    <div class="subHeader">
                        <h3 class="mt-5 mb-4"><mark class="lineText">Invocando Functions com um <b class="blue">Function Constructor</b></mark></h3>
                        <div class="solidLine"></div>
                    </div>
                    <ul><li>Quando uma functions for invocada e for <b>precedida</b> pela palavra <code class="inlineCode">new</code>, essa será uma <strong class="gold">constructor invocation</strong>.</li></ul>
                    <p><b>Exemplo</b> de uma Constructor Invocation ( Invocação por construtor ):</p>
                    <pre class="preTag px-4">
                        <code>
<span class="grey">function myFunction(){
    console.log("Hello World");
}

</span><b>new myFunction</b>;<span class="grey">
//Os parênteses são opcionais nesse caso</span>
                        </code>
                    </pre>
                    <ul>
                        <li>No Javascript, <b class="gold">FUNCTIONS são OBJECTS</b> :
                            <ul class="innerUl"><li>Mesmo parecendo que uma nova function está sendo criada, na realidade, é um novo <b>object</b> que está sendo criado.</li></ul>
                        </li>
                        <li>Uma <b>constructor invocation</b> cria um novo <b>object</b>
                            <ul class="innerUl"><li>Esse novo object herda as propriedades e métodos do seu construtor.</li></ul>
                        </li>
                        <li>A palavra-chave <code class="inlineCode">this</code>, no construtor, <b>não</b> possui um valor.</li>
                        <li>O valor de <code class="inlineCode">this</code> será o novo object criado quando a function for chamada. </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- CALLBACK FUNCTIONS -->
        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4"><mark class="lineText"><b class="gold">Callback</b> Functions</mark></h2>
                <div class="px-5">
                    <ul>

                    </ul>
                </div>
            </div>
        </div>

        <!-- CALL METHOD -->
        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4 my-5"><mark class="lineText"><strong class="gold">Call( )</strong> Method</mark></h2>
                <div class="px-5">
                    <ul>
                        <li>É um method que já é <b>predefinido</b> pelo Javascript</li>
                        <li>Pode ser usado para invocar uma function (method)
                            <ul class="innerUl"><li>Um <b>owner object</b> é usado como argument.</li></ul>
                        </li>
                        <li>Com o <code class="inlineCode">call()</code> um object pode usar <b>methods</b> que pertençam a <b>outros objects</b>.</li>
                    </ul>
                    <p class="mb-05em"><b>Exemplo 1:</b></p>
                    <pre class="preTag px-4">
                        <code>
<span class="grey">const person = {
    fullName: function() {
        return this.firstName + " " + this.lastName;
    }
}

const person1 = {
    firstName:"John",
    lastName: "Doe"
}
const person2 = {
    firstName:"Mary",
    lastName: "Doe"
}

var x = person.fullName</span><b>.call(person1);</b>
<span class="grey">console.log(x); //John Doe</span>
                        </code>
                    </pre>

                    <p class="mb-05em"><b>Exemplo 2:</b> O <code class="inlineCode">call()</code> pode aceitar <b>arguments</b></p>
                    <pre class="preTag px-4">
                        <code>
<span class="grey">const person = {
    fullName: function(city, country) {
        return this.firstName + " " + this.lastName + "," + city + "," + country;
    }
}

const person1 = {
    firstName:"John",
    lastName: "Doe"
}
const person2 = {
    firstName:"Mary",
    lastName: "Doe"
}

var x = person.fullName.</span><b>call(person1, "Contagem", "Brasil")</b><span class="grey">; //Adicionando arguments
console.log(x) // John Doe, Contagem, Brasil</span>
                        </code>
                    </pre>
                </div>
            </div>
        </div>
	
        <!-- APPLY METHOD -->
        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4 my-4"><mark class="lineText"><strong class="gold">Apply( )</strong> Method</mark></h2>
                <div class="px-5">
                    <ul>
                        <li><code class="inlineCode">apply()</code> é <b>similar</b> ao <code class="inlineCode">call()</code> method;</li>
                        <li>As <b>diferenças</b> estão no fato de que:
                            <ul class="innerUl">
                                <li><code class="inlineCode"><b>call()</b></code> aceita os argumentos <b class="red">SEPARADAMENTE</b>;</li>
                                <li><code class="inlineCode"><b>apply()</b></code> aceita os argumentos como um <b class="red">ARRAY</b>.</li>
                            </ul>
                        </li>
                    </ul>
                    
                    <p class="mb-05em"><b>Exemplo:</b> Usando <code class="inlineCode">call()</code> :</p>
                    <pre class="preTag px-4">
                        <code>
<span class="grey">const person = {
    fullName: function(city, country) {
        return this.firstName + "," + city + "," + country;
    }
}
    const person1 = {
    firstName:"João",
    lastName: "Machado"
}
document.getElementById("demo").innerHTML = person.fullName.apply(person1,</span><b> "Contagem", "Brasil"</b><span class="grey">); //Argumentos individuais</span>
                        </code>
                    </pre>

                    <p class="mb-05em"><b>Exemplo:</b> Usando <code class="inlineCode">apply()</code> :</p>
                    <pre class="preTag px-4">
                        <code>
<span class="grey">const person = {
    fullName: function(city, country) {
        return this.firstName + "," + city + "," + country;
    }
}
const person1 = {
    firstName:"João",
    lastName: "Machado"
}
document.getElementById("demo").innerHTML = person.fullName.apply(person1,</span><b> ["Contagem", "Brasil"]</b><span class="grey">); //Argumento em array</span>
                        </code>
                    </pre>
                </div>
            </div>
        </div>  

        <!-- SCOPE AND FUNCTION CLOSURES -->
        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4"><mark class="lineText"><b class="gold">Escopo</b> e <b class="gold">Function Closures</b></mark></h2>
                <div class="px-5">
                    <ul><li>Uma function pode acessar as variáveis definidas <b>dentro</b> dela mesma;</li></ul>
                    <p class="mb-05em"><b>Exemplo:</b> Definindo e usando uma variável dentro de uma function</p>
                    <pre class="preTag px-4">
                        <code>
<span class="grey">function myFunction () {    
    </span><b>let a = 4</b><span class="grey">;	//variável local
    return a * a;
} </span>
                        </code>
                    </pre>
                    <ul>
                        <li>Uma function também pode acessar variáveis definidas fora da própria function:</li>
                    </ul>
                    <p class="mb-05em"><b>Exemplo:</b> Usando uma variável exterior a uma function</p>
                    <pre class="preTag px-4">
                        <code>
<b>let a = 4</b><span class="grey">; //variável global

function myFunction () {
    return a * a;
}</span>
                        </code>
                    </pre>

                    <div class="subHeader">
                        <div class="solidLine"></div>
                        <h3 class="mt-5"><mark class="lineText">Variável <strong class="blue">Global</strong></mark></h3>
                    </div>
                    <ul>
                        <li>São as variáveis que são acessíveis a <b>TODOS</b> os escopos;</li>
                        <p class="mb-05em"><b>Exemplo:</b> Declarando uma Variável Global:</p>
                        <pre class="preTag px-4">
                            <code>
<span class="grey">//Global Scope</span>
<b>var myVar = "Hello World";</b>

<span class="grey">function myFunction() {
    console.log(myVar);
}</span>
                            </code>
                        </pre>
                    </ul>
                    <ul>
                        <li>Variáveis criadas sem palavra-chave <b>sempre</b> serão <b>globais</b>, mesmo se forem criadas dentro de uma function.
                            <ul class="innerUl"><li>Palavras-chaves para declarar variáveis: <b>var, let </b>e<b> const</b>.</li></ul>
                        </li>
                        <p class="mb-05em"><b>Exemplo:</b></p>
                        <pre class="preTag px-4">
                            <code>
<span class="grey">function myFunction() {
    //Escopo local
    </span><b>a = 4</b><span class="grey">;
}

//"a" será considerada uma variável global</span>
                            </code>
                        </pre>
                    </ul>

                    <li><b>Variáveis globais</b> podem ser transformadas em <b>variáveis locais</b> ( privadas ), usando <b class="red">Closures</b>;</li>
                    <div class="subHeader">
                        <div class="solidLine"></div>
                        <h3 class="mt-5"><mark class="lineText">Variável <strong class="blue">Local</strong></mark></h3>
                    </div>
                    <ul>
                        <li>Só pode ser usada <b>dentro</b> da function em que foi definida.</li>
                        <p class="mb-05em"><b>Exemplo:</b></p>
                        <pre class="preTag px-4">
                            <code>
//Global Scope

function myFunction(){
    //Escopo da function

    var a = "Hello World";
    console.log(a);
}

console.log(a); //Erro: not defined
                            </code>
                        </pre>
                    </ul>
                    <ul>
                        <li>Variáveis globais e locais com o <b>mesmo nome</b> são consideradas como <b>variáveis diferentes</b>.
                            <ul class="innerUl"><li>Modificar uma variável não irá alterar a outra.</li></ul>
                        </li>
                        <p class="mb-05em"><b>Exemplo:</b></p>
                        <pre class="preTag px-4">
                            <code>
//Global Scope

var a = "Hey World";

function myFunction(){
    //Escopo da function

    var a = "Hello World";
    console.log(a); //Hello World
}

console.log(a); //Hey World
                            </code>
                        </pre>
                    </ul><br><hr><br>
    
                    <h3>Tempo de vida das variáveis</h3>
                    <ul>
                        <li>Variáveis <b class="red">globais</b> :
                            <ul class="innerUl"><li>São <b>descartadas</b> ao se <b>navegar para outra página</b> ou <b>fechar a janela</b>.</li></ul>
                        </li>
                    </ul>
                    <ul>
                        <li>Variáveis <b class="red">locais</b>:
                            <ul class="innerUl">
                                <li>São <b>criadas</b> quando a função é chamada;</li>
                                <li>São <b>descartadas</b> quando a função é concluída.</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- CLOSURES -->
        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4 mt-5 mb-4"><mark class="lineText"><b class="gold">Closures</b></h2>
                <div class="px-5">
                    <div>
                        <div class="subHeader">
                            <div class="solidLine"></div>
                            <h3><mark class="lineText">Entendendo Closures</mark></h3>
                        </div>
                        <p>
                            A forma mais didática de se entender o funcionamento das Closures é criando uma analogia<br>
                            Iremos usar o ambiente de uma certa empresa para criar essa analogia.<br>
                        </p>
                        <p>
                            Imagine que essa empresa seja dividida em várias partes, cada parte tem o seu papel.<br>
                            O conjunto de todas as partes permite o funcionamento da empresa.<br>
                        </p>
                        <p>
                            Imagine que essa empresa é formada por diversos escritórios, em conjunto eles permitem o funcionamento da empresa<br>
                            Para trabalhar nesses escritórios a empresa precisa de funcionários, que devem seguir regras bem específicas.<br>
                        </p>
                        <p>
                            Cada funcionário tem seu próprio escritório onde ele pode trabalhar e realizar suas tarefas normalmente.<br>
                            A grande diferença é que, nessa empresa, um funcionário só pode entrar em seu próprio escritório, não tendo a permissão de entrar nos escritórios de outros funcionários.<br>
                            Os escritórios fazem parte da empresa, contudo são privados e não podem ser acessados livremente<br>
                            Em uma situação do mundo real essa regra não faria muito sentido, mas como analogia será útil para entender o funcionamento das Closures<br>
                        </p>
                        <p>
                            Os funcionários podem andar pela empresa livremente, só não podem entrar nos escritórios dos outros funcionários<br>

                            Cada funcionário realiza algum trabalho dentro de seu escritório, o conjunto de todos esses escritórios permite com que a empresa funcione<br>
                            Trazendo essa analogia para o código, cada function realiza seus próprios "trabalhos" e o conjunto de todas as functions permite com que o programa funcione<br>
                        </p>
                        <p>

                            Além dos escritórios, existem outros locais locais e atividades dentro da empresa, localizados fora dos escritórios, que também são essenciais para o funcionamento da empresa, e que todos os funcionários podem acessar<br>
                            De mesma maneira, em um código, as functions não são as únicas partes que compôem o código, também existem outras seções fora das functions que são essenciais para o programa funcionar<br>
                        </p>

                        <p>
                            Cada funcionário possui suas próprias ferramentas e trabalhos dentro do seu próprio escritório, e os trabalhos e ferramentas que existem dentro de outros escritórios não podem ser acessados diretamente <br>
                        </p>

                        <p>
                            Caso um funcionário precise de dos dados de outro escritório, ele deve "chamar" o funcionário que trabalhe nesse escritório, para que esse sim lhe forneça os dados necessários<br>
                        </p>
                        <p>
                            No contexto de programação, as ferramentas e processos seriam as variáveis e methods localizadas dentro da function(escritório) e que não podem ser acessados de fora, por um escopo exterior<br>

                            Os funcionários estão representando as closures, ou seja, as functions internas que estão dentro de uma function externa ( closures dentro de uma função externa)<br>
                        </p>
                        <p>
                            Os funcionários(closures) possuem acesso apenas as variáveis e declarações localizados dentro do seu próprio escritório ( escopo da function exterior )<br>

                            Um funcionário é o único meio pelo qual se é possível ter acesso aos valores e dados de um determinado escritório<br>
                        </p>
                        <p>
                            Da mesma maneira, em programação, uma closure é a única forma de se obter os valores localizados dentro de uma function, as closures se responsabilizam por "retornar" os valores para o local onde foram chamadas<br>

                            O funcionário que pediu as informações não possui o acesso direto às variáveis e methods definidos dentro da function exterior(escritório), essa function e todos as suas variáveis e declarações são PRIVADAS, apenas o funcionário que foi chamado ( closure ) e que trabalha dentro desse escritório possui acesso, servindo como ponte para acessar esses dados.<br>
                        </p>
                            
                        <p>
                            A empresa em si é a analogia para o global scope, onde além dos escritórios, também existem outros locais que podem ser acessados pelos funcionários.<br>
                            Os escritórios representam as functions que contêm dentro de si as suas variáveis privadas e as closures(funcionários), que permitem o acesso as essas variáveis.<br>
                        </p>

                        <p>
                            Outros locais como os corredores, banheiros, lanchonetes, salas, etc representam as variáveis e methods declarados no global scope, ou seja, podem ser acessados por todos os funcionários<br>
                            O global scope é basicamente o ambiente "público" por onde todos podem trafegar<br>

                            Como exemplo, uma cafeteira na lanchonete pode ser usada por todos os funcionários, portanto sempre há um risco dela ser quebrada ou estragada por algum funcionário mais desastrado ou que tenha más intenções<br>
                            Da mesma maneira, em programação, variáveis e methods localizados no global scope podem ser alterados por qualquer pessoa, tanto sem querer ou de forma maliciosa.<br>
                        </p>
                        <p>
                            O uso das closures permite com que existam variáveis e declarações privadas dentro de um código, que não podem ser acessadas livremente<br>
                            Só o próprio funcionário tem acesso aos trabalhos realizados dentro do seu escritório<br>
                            O funcionário é a parte "móvel" da escritório, que pode levar os trabalhos feitos lá dentro para outros lugares e outros funcionários, algo que o escritório em si não pode fazer<br>
                            Um determinado escritório pode conter uma impressora que imprime um determinado documento, impressora essa que não pode ser usada por qualquer pessoa, caso outro funcionário precise do documento, ele não pode entrar no escritória para usá-la diretamente, ele deve então pedir para o funcionário responsável pelo escritório fazer isso por ele e "retornar" o documento.
                        </p>
                    </div>
                    <br>
                    <hr>
                    <br>
                    <ul><li>Closures permitem que funções tenha variáveis <b>"privadas"</b></li></ul>
                    <p class="mb-05em"><b>Exemplo:</b></p>
                    <pre class="preTag px-4">
                        <code>
<span class="grey">const add = (function () {
    let counter = 0;
    return </span><b>function () {counter += 1; return counter;}</b><span class="grey">
})();

console.log( add() ); //output: 1
console.log( add() ); //output: 2
console.log( add() ); //output: 3
}</span>
                        </code>
                    </pre>
                    <ul>
                        <li>A variável <code class="inlineCode">add()</code> é <b>atribuída</b> a um valor que está sendo retornado por uma <b>self-invoking function</b>.
                            <ul class="innerUl">
                                <li>A <b>self-invoking function</b> é executada apenas <b class="gold">UMA VEZ</b> ;</li>
                                <li>Ela define o valor da variável "counter" e <b>retorna</b> uma <b>function expression</b>.</li>
                            </ul>
                        </li>
                        
                        <li>Desta forma, <code class="inlineCode">add()</code> torna-se uma <b>function</b>.
                            <ul class="innerUl">
                                <li>Dessa forma, <code class="inlineCode">add()</code> é capaz de acessar o <code class="inlineCode">counter</code> que está no <b>parent scope</b>.</li>
                                <li>Isso é uma <b>Javascript Closure</b>. </li>
                                <li><code class="inlineCode">counter</code> é <b>protegido</b> pelo <b>escopo da anonymous function </b> e só pode ser <b>alterado</b> usando-se a função <code class="inlineCode">add()</code>.</li>
                            </ul>
                        </li>
                    </ul>
                    <br>
                    <hr>
                    <br>
                    <p>
                        <b>variableName</b><br>
                        Apenas o nome da variável, sem parênteses, irá mostrar apenas o próprio código que foi passado para a variável<br>
                    </p>
                    <pre class="preTag px-4">
                        <code>
function myMessage() {
    let message = 'Hello World';
    return function displayMessage() {
        console.log(message);
    };
}

let myVar = myMessage();
console.log(myVar); 
//output: A function que foi atribuída à variável "myVar"

//function displayMessage() {
//    console.log(message);
//};

                        </code>
                    </pre>

                    <p>
                        <b>variableName()</b><br>
                        O nome da variável, com parênteses no final, irá executar a function que foi atribuída à variável.
                    </p>
                    <pre class="preTag px-4">
                        <code>
function myMessage() {
    let message = 'Hello World';
    return function displayMessage() {
        console.log(message);
    };
}

let myVar = myMessage();
myVar(); //output: Hello World
                        </code>
                    </pre>
                </div>
            </div>
        </div>

        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4 mt-5 mb-4"><mark class="lineText">Um Problema do Contador</mark></h2>
                <div class="px-5">
                    <p>
                        Suponha que você queira usar uma variável para contar algo e que esse contador esteja disponível para todas as funções do programa: <br><br>
                        Você pode usar uma <b>variável global</b> e uma <b>função</b> para aumentar o contador <br>
                        Exemplo: <br>
                        <!-- <img src="1.jpg"> -->
                        O problema com essa solução é que qualquer código introduzido na página pode alterar o contador, <b>sem chamar</b> o add(). <br>
                    </p>
                    <p>
                        O contador deve ser local para a função add(), para prevenir que outros códigos possam alterá-lo: <br>
                        <!-- <img src="2.jpg"> -->
                        Não funcionou pois exibimos o contador global, e não o contador local. <br>
                    </p>
                    <p>
                        Podemos remover o contador global e acessar o contador local, permitindo que agora a função retorn o contador local: <br>
                        <!-- <img src="2.jpg"> -->
                        Não funcionou pois o contador local está sendo <b>zerado</b> toda vez que a função é chamada. <br>
                    </p>
                    <p>Uma <strong class="gold">Inner Function</strong> do JavaScript pode resolver isso<br></p>
                    <br><hr><br>
                    <h3>Nested Functions</h3>
                    <ul>
                        <li><b>Todas</b> funções têm acesso ao <b>escopo global</b>.</li>
                            <ul><li>Mais detalhadamente, em JavaScript, todas as funções terão acesso a todos os escopos que estão diretamente "acima" delas (Acesso a todos os escopos que as contêm). </li></ul>
                    </ul>
                    <ul>
                        <li>O JavaScript oferece suporte a <strong>nested functions</strong>.
                            <ul><li>As nested functions têm acesso aos escopos que estão "acima" delas. <br></li></ul>
                    </ul>
                        <p>Exemplo: A função interna <code class="inlineCode">plus()</code> tem acesso a variável do contador na <b>parent function</b></p>
                        <pre class="preTag px-4">
                            <code>
        document.getElementById("demo").innerHTML = add();
        function add() { //Parent Function
            let counter = 0;
            function <b>plus()</b> {
                counter += 1;
            }
            plus();  
            return counter; 
        }
                            </code>
                        </pre>
                    <ul>
                        <li>Isso poderia ter resolvido o problema do contador, se pudéssemos alcançar a função plus() de fora.</li>
                        <li>Também precisamos encontrar uma maneira de executar o counter = 0 apenas uma vez.</li>
                        <li>Para isso será necessário uma "closure"</li>
                    </ul>
                    <br><hr><br>
                </div>
            </div>
        </div>

        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
    </body>
</html>