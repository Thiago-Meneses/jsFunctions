<!DOCTYPE html>
<html lang='en'>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta charset="UTF-8">
        <title>Funções Javascript</title>

        <!-- Bootstrap CSS -->
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
        
        <!-- myGlobalCSS -->
        <!-- <link rel="stylesheet" type="text/css" href="https://thiago-meneses.github.io/myGlobalCSS.css"> -->

        <link rel="stylesheet" type="text/css" href="..\gitHubPages\Thiago-Meneses.github.io\myGlobalCSS.css">

        <!-- FONTS -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@200;300;400;600;700;800;900&display=swap" rel="stylesheet">

        <!-- FONTS -->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Fira+Mono:wght@400;500;700&family=Fira+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,300&family=Roboto+Mono:wght@100;200;300;400;500;600;700&display=swap" rel="stylesheet">
    </head>
    <body>
        <div class="container-lg px-4">
            <h1 class="initialTitle">Funções em Javascript</h1>
            <p>
                Funções são definidas pela palavra-chave "function" <br>
                Funções são <b>objetos</b>
            </p>
            <hr>
        </div>

        <!-- PROPRIEDADES E METHODS -->
        <div class="container-lg">
            <div class="content oloko">
                <div class="boundingLines"></div>
                <div class="px-5 pb-3">
                    <h2><mark class="lineText">Propriedades e Methods de uma Function</mark></h2>
                    <div class="content">
                        <h3 class="px-2"><mark class="lineText"><b class="gold">Propriedades</b> de uma Function</mark></h3>
                        <div class="innerBoundingLines"></div>
                        <div class="px-5">
                            <p>
                                Functions possuem <b>propriedades</b>.<br>
                            </p>
                            <p class="mb-05em">
                                <b>Exemplo</b> com a propriedade <code class="inlineCode">.length</code>:
                            </p>
                            <pre class="px-4 preTag">
                                <code>
function myFunction(a, b) {
    return arguments<b>.length</b>;
}
console.log(myFunction(4, 3)); //Será retornado "2" no console    
                                </code>
                            </pre>
                        </div>
                        <br>
                    </div>
                    
                    <div class="content">
                        <h3 class="px-2"><mark class="lineText"><b class="gold">Methods</b> de uma Function</mark></h3>
                        <div class="innerBoundingLines"></div>
                        <div class="px-5">
                            <p>
                                Functions também possuem <b>methods</b>.
                            </p>
                            <p class="mb-05em">
                                <b>Exemplo</b> com o method <code class="inlineCode">.toString()</code>
                            </p>
                            <div>
                                <pre class="preTag px-4">
                                    <code>
function myFunction(a, b) {
    return a * b;
}
console.log( myFunction.toString() );	//Irá retornar "function myFunction(a, b) { return a * b; }" no console
                                    </code>
                                </pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- FUNCTION DECLARATION VS FUNCTION EXPRESSION -->
        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4"><mark class="lineText">Declaration - Expression</mark></h2>
                <!-- FUNCTION DECLARATIONS -->
                <div class="px-5 py-3">
                    <div class="content">
                        <div class="innerBoundingLines"></div>
                        <h3 class="px-2"><mark class="lineText">Function <b class="gold">Declaration</b></mark></h3>
                        <div class="px-4">
                            <ul>
                                <li>É a forma mais comum, normalmente pela qual se aprende a definir uma function pela primeira vez</li>
                                <li>Também recebe o nome de Function Statement</li>
                                <li>Funções declaradas <b>NÃO</b> são <b>executadas imediatamente</b>;</li>
                                <li>Function Declarations são içadas (hoisted)</li>
                                <li>São executadas apenas quando <b>invocadas</b>;</li>
                                <li>Function Declarations não são <b>executable statements</b>, não é comum terminá-los com <code class="inlineCode">;</code></li>
                            </ul>
                            <p>
                                Exemplo:
                            </p>
                            <pre class="preTag px-4">
                                <code>
//Sem o uso de ponto e vírgula

function functionName(parâmetros) {
    console.log("Hello world");
}

functionName(); //Chamando uma function declaration
                                </code>
                            </pre>
                        </div>
                    </div>
                </div>

                <!-- FUNCTION EXPRESSION -->
                <div class="px-5 py-3">
                    <div class="content">
                        <div class="innerBoundingLines"></div>
                        <h3 class="px-2"><mark class="lineText">Function <b class="gold">Expression</b></mark></h3>
                        <div class="px-4">
                            <ul>
                                <li>Uma function expression pode ser <b>armazenada</b> em uma <b>variável</b>;</li> 
                                <li>A variável em que a function foi armazenada poderá ela mesma ser <b>usada</b> como uma <b>function</b>;</li>
                                    <ul class="innerUl">
                                        <li>A variável será usada para <b>invocar a função</b>;</li>
                                        <li>Por causa disso, a função não precisará de um nome para identificá-la;</li>
                                        <li>Uma função que não tem nome é chamada de <b>função anônima</b></li> 
                                    </ul>
                                </li>
                                <li>Function Expressions terminam com <code class="inlineCode">;</code> pois fazem parte de um "executable statement". (instrução executável)</li> 
                                <li>Uma function expression sempre terá um <b>valor constante</b>.</li>
                                    <ul class="innerUl"><li>Portanto, usar "const" é mais seguro do que usar "var"</li></ul>
                                <li>Function Expressions não são içadas (hoisted)
                                    <ul class="innerUl"><li>Apenas a variável que recebe a function expression é em si içada, mas a própria function não vai ser.</li></ul>
                                </li>
                            </ul>
                            <p>
                                <b>Exemplo</b> de Function Expression:
                            </p>
                            <pre class="preTag px-4">
                                <code>
const a = function (x, y) {return x * y};
let b = a(4, 3);
                                </code>
                            </pre>
                            <p>
                                <b>Exemplo</b> de uma Function Expression nomeada:
                            </p>
                            <pre class="preTag px-4">
                                <code>
//Qualquer nome pode ser dado para a function, mas recomenda-se usar o mesmo nome dado a variável, por organização
var <b>nomeVar</b> = function <b>nomeFunction()</b>{
    console.log('Hello world');
}

//Modo recomendado
var <b>nomeVar</b> = function <b>nomeVar()</b>{
    console.log('Hello world');
}
                                </code>
                            </pre>
                            <div class="subHeader">
                                <div class="solidLine"></div>
                                <h4><mark class="lineText"><b class="blue">Self-Invoking Functions</b></mark></h4>
                            </div>
                            
                            <ul>
                                <li>São as functions invocadas <b>automaticamente</b>, sem precisar de serem chamadas;</li>
                                <li>Apenas <b class="red">Function Expressions</b> podem ser invocadas automaticamente;</li>
                                <li>Function Declarations <b>NÃO podem</b> ser invocadas automaticamente;</li>
                                <li>Adiciona-se <code class="inlineCode">( )</code> <b>em volta</b> da function e <b>após</b> ela, para indicá-la como uma <b>function expression</b>;</li>
                            </ul>
                            <p class="mb-05em"><b>Exemplo:</b> Anonymous Self-invoking Function </p>
                            <pre class="preTag px-4">
                                <code>
<span class="bold">(</span><span class="grey">function () {
    let x = "Hello World !";
}</span><b>)()</b>;
                                </code>
                            </pre>

                            <div class="subHeader">
                                <div class="solidLine"></div>
                                    <h4 class="px-4"><mark class="lineText"><b class="blue">Anonymous Functions</b></mark></h4>
                            </div>
                            <ul>
                                <li>São as functions que <b>não possuem nome</b>;</li>
                                <li>Functions são armazenadas em variáveis <b>NÃO</b> precisam de nomes
                                    <ul class="innerUl"><li>Serão sempre invocadas usando o próprio nome da variável.</li></ul>
                                </li>
                            </ul>

                            <div class="subHeader">
                                <div class="solidLine"></div>
                                    <h4 class="px-4"><mark class="lineText"><b class="blue">Arrow Functions</b></mark></h4>
                            </div>
                            <div class="px-5">
                            </div>

                            <ul>
                                <li>Arrow Functions <b>sempre</b> serão <b>function expressions</b>, e nunca function declarations
                                    <ul class="innerUl"><li>Arrow functions permitem uma sintaxe menor para escrever function expressions</li></ul>
                                </li>
                                <li>Não são necessários os termos:
                                    <ul class="innerUl">
                                        <li><code class="inlineCode"><b>function</b></code></li>
                                        <li><code class="inlineCode"><b>return</b></code> - Quando a function não ter mais de uma linha</li>
                                        <li><code class="inlineCode"><b>{ }</b></code> - Quando a function não ter mais de uma linha</li>
                                        <li><code class="inlineCode"><b>( )</b></code> - Quando só haja 1 parâmetro</li>
                                    </ul>
                                </li>
                            </ul>

                            <ul>
                                <li>Caracterísitcas
                                    <ul class="innerUl">
                                        <li>Não possuem <b>this</b>;</li>
                                        <li>Não são adequadas para definir <b>Object Methods</b>;</li>
                                        <li>Não são içadas, devem ser <b>definidas antes de serem usadas</b>. ( not hoisted )</li>
                                    </ul>   
                                </li>
                            </ul>

                            <h5 class="px-3">Transformando declarações comuns em arrow functions</h5>
                            <ol>
                                <li class="mb-05em">A palavra-chave <code class="inlineCode">function</code> não é usada:</li>
                                <pre class="preTag px-4">
                                    <code>
let myVar = <span class="weak">function</span>(data) {
    return "Hello World" + data;
}
</code>
                                </pre>
                                <pre class="preTag px-4 mb-3em">
                                    <code>
let myVar = (data) {
    return "Hello World" + data;
}
                                    </code>
                                </pre>

                                <li class="mb-05em">Removendo <code class="inlineCode">{ }</code> e <code class="inlineCode">return</code>, apenas quando a function for <b>single statement</b>:</li>
                                <pre class="preTag px-4">
                                    <code>
let myVar = (data) <span class="weak">{ return </span> "Hello World" + data; <span class="weak">}</span>
                                    </code>
                                </pre>
                                <pre class="preTag px-4 mb-3em">
                                    <code>
let myVar = (data) "Hello World" + data;

//Mesmo opcionais é uma boa prática usá-los sempre
                                    </code>
                                </pre>

                                <li class="mb-05em">Adicionando a Arrow Function <code class="inlineCode">=></code></li>
                                <pre class="preTag px-4 mb-3em">
                                    <code>
let myVar = (data) => "Hello World" + data;
                                    </code>
                                </pre>

                                <li>Com um único parâmetro, os parênteses podem ser removidos</li>
                                <pre class="preTag px-4 mb-3em">
                                    <code>
let myVar = data => "Hello World" + data;
                                    </code>
                                </pre>
                            </ol>

                            <p class="mb-05em"><b>Exemplo 1:</b> Adicionando um valor aos elementos de um array</p>
                            <pre class="preTag px-4">
                                <code>
<span class="grey">let array = [1,2,3,4,5];

//Arrow Function
let array2 = array.map</span><span class="bold">(v => v + 2)</span><span class="grey">,

//Declaração comum
let array3 = array.map(</span><span class="bold">function(v) { return v + 2; }</span><span class="grey">);

console.log(array2); //[3,4,5,6,7]
console.log(array3); //[3,4,5,6,7]</span>
                                </code>
                            </pre>

                            <p class="mb-05em"><b>Exemplo 2:</b> Arrow Function com mais de uma linha e mais de um parâmetro:</p>
                            <pre class="preTag px-4">
                                <code>
let greeting = (time, name) => {
    if (time === "day") return "Morning " + name;
    if (time === "night") return "Evening " + name;
}

let greet = greeting("day", "Steve");
console.log(greet); // Morning Steve
                                </code>
                            </pre>
                        </div>
                    </div>     
                </div>
            </div>
        </div>

        <!-- FUNCTION CONSTRUCTOR -->
        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4"><mark class="lineText">Function( ) Contructor</mark></h2>
                <div class="px-4 py-3">

                    <ul>
                        <li>Funções também podem ser definidas com o construtor <code class="inlineCode">Function()</code> </li>
                        <li> O uso desse construtor é <b>opcional</b></li>
                    </ul>
                    Exemplo:
                    <pre class="preTag">
                        <code>
const myFunction = new Function("a", "b", "return a * b");
let x = myFunction(4, 3);
                        </code>
                    </pre>
        
                    Exemplo:
                    <pre class="preTag">
                        <code>
const myFunction = function (a, b) {return a * b};
let x = myFunction(4, 3);
                        </code>
                    </pre>
                </div>

            </div>
        </div>

        <!-- Bizu -->
        <div class="container-lg">
            <div class="content">
                <h2 class="px-4 mb-5"><mark class="lineText"><b class="red">Bizu</b></mark></h2>
                <div class="boundingLines"></div>
                <div class="px-4">
                    <ul class="px-5">
                        <li>Funções podem ser usadas como <b>valores</b> e também <b>em expressões</b>.</li>
                        <li>Exemplo como <b>valor</b>:</li>
                    </ul>
                    <div class="px-5">
                    <pre class="preTag ps-4">
                        <code>
function myFunction(a, b) {
    return a * b;
}
let x = <b>myFunction(4, 3)</b>;	
console.log(x);

//Usada como valor
//Resposta 12 no console</code>
                    </pre>

                    <ul>
                        <li>Exemplo em uma <b>expressão</b>:</li>
                    </ul>
                    <pre class="preTag ps-4">
                        <code>
function myFunction(a, b) {
    return a * b;
}
let x = <b>myFunction(4, 3)</b> * 2;	
console.log(x);		

//Usada como valor em uma expressão
//Resultado 24 no console</code>
                    </pre>
                </div>
                </div>
            </div>
        </div>

        <!-- FUNCTION PARAMETERS / FUNCTION ARGUMENTS -->
        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4 mb-5"><mark class="lineText">Function Parameters / Function Arguments</mark></h2>
                <div class="px-5">
                    <!-- FUNCTION PARAMETERS -->
                    <div class="subHeader">
                        <h3><mark class="lineText">Function <b class="blue">Parameters</mark></b></h3>
                        <div class="solidLine"></div>
                    </div>
                    <div class="px-5">
                        <p>Exemplo:</p>
                        <pre class="preTag px-4">
                            <code>
function functionName(<b>parameter1, parameter2, parameter3</b>){
    ...
}
                            </code>
                        </pre>
                        <ul>
                            <li>São os <b>nomes</b> listados na <b class="red">declaração da função</b></li>
                            <li>JavaScript function definitions do not specify data types for parameters.</li>
                            <li>As Funções JavaScript:
                                <ul>
                                    <li>Não verificam o <b class="red">tipo</b> <b>dos argumentos</b> passados.</li>
                                    <li>Não verificam o <b class="red">número</b> <b>de argumentos</b> recebidos.</li>
                                </ul>
                            </li>
                        </ul>
                        <h4>Default Parameter</h4>
                        <ul>
                            <li>Uma função pode ser chamada com <b>argumentos faltando</b> (menos do que foram declarados).</li>
                                <ul>
                                    <li>Os valores ausentes serão considerados como <code class="inlineCode">undefined</code>;</li>
                                    <li>Existem casos em que isso pode ser aceitável;</li>
                                    <li>Contudo, no geral se <b>atribui</b> um valor <b>default</b> (predefinido) ao parameter.</li>
                                </ul>
                            </li>
                            <li>Exemplo:</li>
                        </ul>
                        <pre class="preTag px-4">
                            <code>
function <b>myFunction(x, y)</b> {
if (y === undefined) { //Atribui o valor 2 como default a 'y', quando este for 'undefined'
y = 2;
}
return x * y;
}
console.log( <b>myFunction(4)</b> );

//Função possui 2 parameters mas é invocada com apenas 1 parameter
//Resultado 8 no console
                            </code>
                        </pre>
                    </div><br>

                    <!-- FUNCTION ARGUMENTS -->
                    <div class="subHeader">
                        <h3 class="my-4"><mark class="lineText">Function <b class="blue">Arguments</b></mark></h3>
                        <div class="solidLine"></div>
                    </div>
                    <div class="px-5">
                        <ul>
                            <li>São os <b>valores verdadeiros</b>;</li>
                            <li>São os valores que realmente são <b>passados</b> e <b>recebidos</b> pela função.</li>
                        </ul>
                        <h4 class="my-5">O <code class="inlineCode">Arguments</code> Object</h4>
                        <ul>
                            <li><code class="inlineCode">arguments</code> é um <b>Object</b>, muito semelhante a um <b>array</b>.
                                <ul>
                                    <li>É um object interno das funções do Javascript;</li>
                                    <li>Ele pode ser acessado dentro das funções;</li>
                                    <li>Ele contêm os valores dos arguments passados para a função.</li>
                                    <li>Uma função pode ser invocada com mais arguments do que foram declarados inicialmente</li>
                                        <ul><li>Esses arguments "a mais" podem ser alcançados com o <code class="inlineCode">arguments</code> object" </li></ul>
                                </ul>
                            </li>
                            <li>Exemplo:</li>
                        </ul>
                        <pre class="preTag px-4">
                            <code>
function func1(a, b, c) {
    console.log(<b>arguments[0]</b>);
    // output esperado: 1
    
    console.log(<b>arguments[1]</b>);
    // output esperado: 2
    
    console.log(<b>arguments[2]</b>);
    // output esperado: 3
}
    
func1(1, 2, 3);
                            </code>
                        </pre>
                        <ul>
                            <li>
                                Os <code class="inlineCode">Arguments</code> são passados por <b>valor</b>
                                <ul>
                                    <li>Quando uma função for chamada, os parameters serão os argument dela </li>
                                    <li>Os JavaScript Arguments são passados por valor: a função só conhece os valores e não a localização dos arguments.</li>    
                                    <li>Quando uma função altera o valor de um argument o valor original do parameter NÃO é alterado;</li> 
                                    <li>Alterações nos arguments <b>NÃO SÃO VISÍVEIS FORA</b> da função.</b></li> 
                                    </li>
                                </ul>
                            </li>
                        </ul>
                        <ul>
                            <li>
                                Os <code class="inlineCode">Objects</code> são passados por <b>referência</b>
                                <ul>
                                    <li>No javascript, <b>Object References</b> são valores, por causa disso, Objects vão se comportar como se fossem passados por referência</li>
                                    <li>Se uma função altera o valor de uma propriedade do object, ela também vai alterar o valor original</li>
                                    <li>Alterações nas propriedades do object <b>SÃO VISÍVEIS FORA</b> da função.</b>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- THIS KEYWORD -->
        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4"><mark class="lineText">Palavra-chave <b class="gold">this</b></mark></h2>
                <div class="px-5">
                    <ul>
                        <li>No JavaScript todas as funções são métodos, que pertencem a algum objeto</li>
                        <li>As funções que não pertencem a um objeto específico, pertencem ao objeto global (global object)</li>    
                    </ul>
                    <ul>
                        <li>Nesse sentido, <code class="inlineCode">this</code> se refere ao <b>"dono"</b> dessa função, ou seja, o objeto que é o <b>proprietário</b> da função.
                        <li>Propriedades do <code class="inlineCode">this</code>:
                            <ul>
                                <li>Quando usado em uma função, representa o <b>object</b> que <b>possui</b> essa função;</li>
                                <li>É uma palavra-chave, a qual <b>não</b> pode ter o seu <b>valor alterado</b>;</li>
                                <li><b>Não</b> é uma variável.</li>
                            </ul>
                        </li>
                        <li>When a function is called without an owner object, the value of "this" becomes the global object.</li>
                        <li>Em um navegador da web, o global object é a <b>janela do browser</b>.</li>
                    </ul>
                    <p>Exemplo</p>
                    <pre class="preTag px-4">
                        <code>
let x = myFunction();
function myFunction() {
    return <b>this</b>;
}
console.log(x); 

//Será retornado <b>[object Window]</b>
                        </code>
                    </pre>
                    <ul>
                        <li>Invocar uma função como uma <b>global function</b> faz com que o valor de <code class="inlineCode">this</code> seja o <b class="red">global object</b>. </li>
                        <li>Usar o <code class="inlineCode">window object</code> como uma variável pode facilmente travar o seu programa.</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- EVOKING FUNCTIONS IN JAVASCRIPT -->
        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4"><mark class="lineText">Invocação de Funções no Javascript</mark></h2>
                <div class="px-5">
                    <ul>
                        <li>O código dentro de uma função não é executado quando a função é definida, mas sim quando a função é <b>invocada</b>. </li>
                        <li>É comum usar o termo <b>call a function</b> (Chamar uma função) ao invés de <b>invoke a function</b> (Invocar uma função). </li>
                        <li>Será usado o termo <b>invocar</b>, pois uma função pode ser <b>invocada SEM ser chamada</b>. </li>
                        <li>Exemplo:</li>
                    </ul>
                    <pre class="preTag px-4">
                        <code>
function myFunction(a, b) { 
    return a * b; 
} 
var x = myFunction(10, 2)		 
var y = window.myFunction(10, 2)	//"x" e "y" recebem o mesmo valor 
console.log(x); 	
console.log(y);
                        </code>
                    </pre>
                    <ul>
                        <li>A função acima não pertence a nenhum object</li>
                            <ul>
                                <li>Contudo, no Javascript, <b>SEMPRE HAVERÁ</b> um object padrão denominado <b class="gold">global object</b></li>
                                <li>O <b>global object</b> padrão é a própria <b>página HTML</b>, portanto, a função acima pertence à página HTML.</li>
                            </ul>
                        <li>In a browser the page object is the browser window. The function above automatically becomes a window function.</li>
                        <li><code class="inlineCode">myFunction()</code>  e <code class="inlineCode">window.myFunction()</code> são a mesma função</li>
                    </ul>
            
                    <div class="subHeader">
                        <h3 class="mt-5 mb-4"><mark class="lineText">Invocando Functions como um <b class="red">Method</b></mark></h3>
                        <div class="solidLine"></div>
                    </div>
                    <ul>
                        <li>No JavaScript, funções podem ser definidas como sendo <b class="red">Methods</b> de um object. </li>
                        <li>Exemplo: Criar um object, com as propriedades <code class="inlineCode">firstName</code> e <code class="inlineCode">lastName</code> e um method <code class="inlineCode">fullName</code></li>
                    </ul>
                    <pre class="preTag px-4">
                        <code>
const myObject = { 
    firstName:"John", 
    lastName: "Doe", 
    fullName: function() { 
        return this.firstName + " " + this.lastName;
    } 
} 
var x = myObject.fullName(); 
console.log(x);		//John Doe 
                        </code>
                    </pre>
                    <ul>
                        <li>O method <code class="inlineCode">fullName</code> é uma função.
                            <ul>
                                <li>A função pertence ao object <code class="inlineCode">myObject</code></li>
                                <li><code class="inlineCode">myObject</code> é o "proprietário" da função.</li>
                            </ul>
                        </li>
                        <li>A palavra-chave <b>this</b> se refere ao objeto que <b>possui</b> o código
                            <ul><li>Nesse caso, this terá o valor de <code class="inlineCode">myObject</code></li></ul>
                        </li>
                        <li>Invocar uma função como um method de um object faz com que o valor de <b>this</b> seja o próprio <b>object</b> onde a função foi invocada.</li>
                    </ul>
            
                    <div class="subHeader">
                        <h3 class="mt-5 mb-4"><mark class="lineText">Invocando Funções com um <b class="red">Function Constructor</b></mark></h3>
                        <div class="solidLine"></div>
                    </div>
                    <ul>
                        <li>Quando uma função for invocada e for <b>precedida</b> pela palavra <code class="inlineCode">new</code>, essa será uma <strong class="gold">constructor invocation</strong></li>
                        <li>No Javascript, <b>funções</b> são <b>objects</b>
                            <ul><li>Mesmo parecendo que uma nova função está sendo criada, na realidade é um objeto que está sendo criado.</li></ul>
                        </li>
                        <li>Uma <b>constructor invocation</b> cria um novo <b>object</b>
                            <ul><li>Esse novo object herda as propriedades e métodos do seu construtor.</li></ul>
                        </li>
                        <li>A palavra-chave <code class="inlineCode">this</code> no construtor <b>não</b> possui um valor.</li>
                        <li>O valor de <code class="inlineCode">this</code> será o novo object criado quando a função for chamada. </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4"><mark class="lineText"><b class="gold">Callback</b> Functions</mark></h2>
                <div class="px-5">
                    <ul>

                    </ul>
                </div>
            </div>
        </div>

        <!-- CALL METHOD -->
        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4 my-5"><mark class="lineText"><strong class="gold">CALL( )</strong> Method</mark></h2>
                <div class="px-5">
                    <ul>
                        <li><code class="inlineCode">call()</code> é um method que já é <b>predefinido</b> pelo Javascript</li>
                        <li>Pode ser usado para invocar uma função (method)
                            <ul><li>Um <b>owner object</b> é usado como argument.</li></ul>
                        </li>
                        <li>Com o <code class="inlineCode">call()</code> um object pode usar <b>methods</b> pertencentes a <b>outro object</b></li>
                        <li>Exemplo:</li>
                    </ul>
                    <pre class="preTag px-4">
                        <code>
const person = {
    fullName: function() {
        return this.firstName + " " + this.lastName;
    }
}

const person1 = {
    firstName:"John",
    lastName: "Doe"
}
const person2 = {
    firstName:"Mary",
    lastName: "Doe"
}
var x = person.fullName.call(person1);
console.log(x);
                        </code>
                    </pre>
                    <ul>
                        <li><code class="inlineCode">call()</code> aceita <b>arguments</b></li>
                        <li>Exemplo:</li>
                    </ul>
                    <pre class="preTag px-4">
                        <code>
const person = {
    fullName: function(city, country) {
        return this.firstName + " " + this.lastName + "," + city + "," + country;
    }
}

const person1 = {
    firstName:"John",
    lastName: "Doe"
}
const person2 = {
    firstName:"Mary",
    lastName: "Doe"
}

var x = person.fullName.<b>call(person1, "Contagem", "Brasil")</b>; //Arguments
console.log(x) // John Doe, Contagem, Brasil
                        </code>
                    </pre>
                </div>
            </div>
        </div>
	
        <!-- APPLY METHOD -->
        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4 my-4"><mark class="lineText"><strong class="gold">Apply( )</strong> Method</mark></h2>
                <div class="px-5">
                    <ul>
                        <li><code class="inlineCode">apply()</code> é <b>similar</b> ao método <code class="inlineCode">call()</code></li>
                        <li>A <b>grande diferença</b> está no fato de que:
                            <ul>
                                <li><code class="inlineCode">call()</code> aceita os argumentos <b class="red">SEPARADAMENTE</b>;</li>
                                <li><code class="inlineCode">apply()</code> aceita os argumentos como um <b class="red">ARRAY</b></li>
                            </ul>
                        </li>
                    </ul>
                    
                        ex: método call() <br>
                    <pre class="preTag px-4">
                        <code>
const person = {
    fullName: function(city, country) {
        return this.firstName + "," + city + "," + country;
    }
}
    const person1 = {
    firstName:"João",
    lastName: "Machado"
}
document.getElementById("demo").innerHTML = person.fullName.apply(person1, "Contagem", "Brasil"); 	//Argumentos separados
                        </code>
                    </pre>
                    <ul><li>Exemplo: método apply() </li></ul>
                    <pre class="preTag px-4">
                        <code>
const person = {
    fullName: function(city, country) {
        return this.firstName + "," + city + "," + country;
    }
}
const person1 = {
    firstName:"João",
    lastName: "Machado"
}
document.getElementById("demo").innerHTML = person.fullName.apply(person1, ["Contagem", "Brasil"]); 	//Argumento em array
                        </code>
                    </pre>

                    <div class="subHeader">
                        <div class="solidLine"></div>
                        <h3 class="mt-5 mb-4"><mark class="lineText">Simular o <code class="inlineCode">max()</code> method em arrays</mark></h3>
                    </div>
                    <ul>
                        <li>Você pode encontrar o maior número de uma lista de números usando o method <code class="inlineCode">Math.max()</code>: <br></li>
                        <li>Os arrays JavaScript <b>não</b> têm um method <b>max()</b></li>
                        <li>Exemplo:</li>
                    </ul>                 
                    <pre class="preTag px-4">
                        <code>
document.getElementById("demo").innerHTML = Math.max.apply(null, [1,2,3]);

//Resultado:  3
                        </code>
                    </pre>
                    <ul>
                        <li>O primeiro argumento (null) não é usado nesse caso, sendo assim irrelevante</li>
                        <li>Também pode ser escrito como:</li>
                    </ul>
                    <pre class="preTag px-4">
                        <code>
Math.max.apply(Math, [1,2,3]);</code>
                    </pre>
                    <pre class="preTag px-4">
                        <code>
Math.max.apply(" ", [1,2,3]);</code>
                    </pre>
                    <pre class="preTag px-4">
                        <code>
Math.max.apply(0, [1,2,3]);</code>
                    </pre>
                    <div class="subHeader">
                        <div class="solidLine"></div>
                        <h3 class="mt-5 mb-4"><mark class="lineText">Javascript <b class="red">Strict Mode</b></mark></h3>
                    </div>
                    <ul>
                        <li>No <b>strict mode</b>:
                            <ul><li>Se o primeiro argument do <code class="inlineCode">apply()</code> não for um object, o method <code class="inlineCode">apply()</code> se tornará o <b>proprietário</b> (objeto) da função invocada.</li></ul>
                        </li>
                        <li>No <b>non-strict mode</b>:
                            <ul><li>O <b>global object</b> se torna o <b>proprietário</b> da função</li></ul>
                        </li>
                    </ul>
                </div>
            </div>
        </div>  

        <!-- SCOPE AND FUNCTION CLOSURES -->
        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4"><mark class="lineText">Escopo e <mark class="red">Function Closures</mark></h2>
                <div class="px-5">
                    <ul>
                        <li>Uma função pode acessar todas as variáveis definidas dentro dela mesma </li>
                        <li>Exemplo:</li>
                    </ul>
                    <pre class="preTag px-4">
                        <code>
function myFunction () {    
    let a = 4;		//Nesse caso "a" é uma variável local
    return a * a;
} 
                        </code>
                    </pre>
                    <ul>
                        <li>Uma função também pode acessar variáveis definidas fora da função:</li>
                        <li>Exemplo:</li>
                    </ul>
                    <pre class="preTag px-4">
                        <code>
    let a = 4;			//Nesse caso "a" é uma variável global
    function myFunction () {
        return a * a;
    }
                        </code>
                    </pre>

                    <div class="subHeader">
                        <div class="solidLine"></div>
                        <h3 class="mt-5"><mark class="lineText">Variável <strong class="blue">Global</strong></mark></h3>
                    </div>
                    <ul>
                        <li>São acessíveis a <b>todos</b> os escopos;</li>
                        <li>Variáveis globais podem ser transformadas em variáveis locais (privadas), usando <b>closures</b>;</li>
                        <li>Variáveis criadas <b>sem palavra-chave</b> (var, let ou const) <b>sempre</b> serão globais, mesmo se forem criadas dentro de uma função;</li>
                        <li>Exemplo:</li>
                    </ul>
                    <pre class="preTag px-4">
                        <code>
    function myFunction() {
        a = 4;
    }

    //Será considerada uma variável global
                        </code>
                    </pre>

                    <div class="subHeader">
                        <div class="solidLine"></div>
                        <h3 class="mt-5"><mark class="lineText">Variável <strong class="blue">Local</strong></mark></h3>
                    </div>
                    <ul>
                        <li>Só pode ser usada <b>dentro</b> da função onde está definida.</li>
                        <li>Variáveis globais e locais com o <b>mesmo nome</b> são consideradas como <b>variáveis diferentes</b>.
                            <ul><li>Modificar uma variável não irá alterar a outra.</li></ul>
                        </li>
                    </ul><br><hr><br>
    
                    <h3>Tempo de vida das variáveis</h3>
                    <ul>
                        <li>Variáveis <b class="red">globais</b> :
                            <ul>
                                <li>São <b>descartadas</b> ao se <b>navegar para outra página</b> ou <b>fechar a janela</b>.</li>
                            </ul>
                        </li>
                    </ul>
                    <ul>
                        <li>Variáveis <b class="red">locais</b>:
                            <ul>
                                <li>São <b>criadas</b> quando a função é chamada;</li>
                                <li>São <b>descartadas</b> quando a função é concluída.</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- CLOSURES -->
        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4 mt-5 mb-4"><mark class="lineText"><b class="gold">Closures</b></h2>
                <div class="px-5">
                    <div>
                        <div class="subHeader">
                            <div class="solidLine"></div>
                            <h3><mark class="lineText">Entendendo Closures</mark></h3>
                        </div>
                        <p>
                            A forma mais didática de se entender o funcionamento das Closures é criando uma analogia<br>
                            Iremos usar o ambiente de uma certa empresa para criar essa analogia.<br>
                        </p>
                        <p>
                            Imagine que essa empresa seja dividida em várias partes, cada parte tem o seu papel.<br>
                            O conjunto de todas as partes permite o funcionamento da empresa.<br>
                        </p>
                        <p>
                            Imagine que essa empresa é formada por diversos escritórios, em conjunto eles permitem o funcionamento da empresa<br>
                            Para trabalhar nesses escritórios a empresa precisa de funcionários, que devem seguir regras bem específicas.<br>
                        </p>
                        <p>
                            Cada funcionário tem seu próprio escritório onde ele pode trabalhar e realizar suas tarefas normalmente.<br>
                            A grande diferença é que, nessa empresa, um funcionário só pode entrar em seu próprio escritório, não tendo a permissão de entrar nos escritórios de outros funcionários.<br>
                            Os escritórios fazem parte da empresa, contudo são privados e não podem ser acessados livremente<br>
                            Em uma situação do mundo real essa regra não faria muito sentido, mas como analogia será útil para entender o funcionamento das Closures<br>
                        </p>
                        <p>
                            Os funcionários podem andar pela empresa livremente, só não podem entrar nos escritórios dos outros funcionários<br>

                            Cada funcionário realiza algum trabalho dentro de seu escritório, o conjunto de todos esses escritórios permite com que a empresa funcione<br>
                            Trazendo essa analogia para o código, cada function realiza seus próprios "trabalhos" e o conjunto de todas as functions permite com que o programa funcione<br>
                        </p>
                        <p>

                            Além dos escritórios, existem outros locais locais e atividades dentro da empresa, localizados fora dos escritórios, que também são essenciais para o funcionamento da empresa, e que todos os funcionários podem acessar<br>
                            De mesma maneira, em um código, as functions não são as únicas partes que compôem o código, também existem outras seções fora das functions que são essenciais para o programa funcionar<br>
                        </p>

                        <p>
                            Cada funcionário possui suas próprias ferramentas e trabalhos dentro do seu próprio escritório, e os trabalhos e ferramentas que existem dentro de outros escritórios não podem ser acessados diretamente <br>
                        </p>

                        <p>
                            Caso um funcionário precise de dos dados de outro escritório, ele deve "chamar" o funcionário que trabalhe nesse escritório, para que esse sim lhe forneça os dados necessários<br>
                        </p>
                        <p>
                            No contexto de programação, as ferramentas e processos seriam as variáveis e methods localizadas dentro da function(escritório) e que não podem ser acessados de fora, por um escopo exterior<br>

                            Os funcionários estão representando as closures, ou seja, as functions internas que estão dentro de uma function externa ( closures dentro de uma função externa)<br>
                        </p>
                        <p>
                            Os funcionários(closures) possuem acesso apenas as variáveis e declarações localizados dentro do seu próprio escritório ( escopo da function exterior )<br>

                            Um funcionário é o único meio pelo qual se é possível ter acesso aos valores e dados de um determinado escritório<br>
                        </p>
                        <p>
                            Da mesma maneira, em programação, uma closure é a única forma de se obter os valores localizados dentro de uma function, as closures se responsabilizam por "retornar" os valores para o local onde foram chamadas<br>

                            O funcionário que pediu as informações não possui o acesso direto às variáveis e methods definidos dentro da function exterior(escritório), essa function e todos as suas variáveis e declarações são PRIVADAS, apenas o funcionário que foi chamado ( closure ) e que trabalha dentro desse escritório possui acesso, servindo como ponte para acessar esses dados.<br>
                        </p>
                            
                        <p>
                            A empresa em si é a analogia para o global scope, onde além dos escritórios, também existem outros locais que podem ser acessados pelos funcionários.<br>
                            Os escritórios representam as functions que contêm dentro de si as suas variáveis privadas e as closures(funcionários), que permitem o acesso as essas variáveis.<br>
                        </p>

                        <p>
                            Outros locais como os corredores, banheiros, lanchonetes, salas, etc representam as variáveis e methods declarados no global scope, ou seja, podem ser acessados por todos os funcionários<br>
                            O global scope é basicamente o ambiente "público" por onde todos podem trafegar<br>

                            Como exemplo, uma cafeteira na lanchonete pode ser usada por todos os funcionários, portanto sempre há um risco dela ser quebrada ou estragada por algum funcionário mais desastrado ou que tenha más intenções<br>
                            Da mesma maneira, em programação, variáveis e methods localizados no global scope podem ser alterados por qualquer pessoa, tanto sem querer ou de forma maliciosa.<br>
                        </p>
                        <p>
                            O uso das closures permite com que existam variáveis e declarações privadas dentro de um código, que não podem ser acessadas livremente<br>
                            Só o próprio funcionário tem acesso aos trabalhos realizados dentro do seu escritório<br>
                            O funcionário é a parte "móvel" da escritório, que pode levar os trabalhos feitos lá dentro para outros lugares e outros funcionários, algo que o escritório em si não pode fazer<br>
                            Um determinado escritório pode conter uma impressora que imprime um determinado documento, impressora essa que não pode ser usada por qualquer pessoa, caso outro funcionário precise do documento, ele não pode entrar no escritória para usá-la diretamente, ele deve então pedir para o funcionário responsável pelo escritório fazer isso por ele e "retornar" o documento.
                        </p>
                    </div>
                    <br>
                    <hr>
                    <br>
                    <p>
                        Closures permitem que funções tenha variáveis <b>"privadas"</b> <br>
                        Exemplo:
                    </p>
                    <pre class="preTag px-4">
                        <code>
const add = (function () {
    let counter = 0;
    return function () {counter += 1; return counter;}
})();

function myFunction(){
    document.getElementById("demo").innerHTML = add();
}
                        </code>
                    </pre>
                    <ul>
                        <li>A variável <code class="inlineCode">add()</code> é atribuída ao valor de retorno de uma <b>self-invoking function</b>.
                            <ul>
                                <li>A <b>self-invoking function</b> é executada apenas <b>UMA vez</b>.</li>
                                <li>Ela define o contador para <b>zero</b> e retorna uma <b>function expression</b>.</li>
                            </ul>
                        </li>
                        
                        <li>Desta forma, <code class="inlineCode">add</code> torna-se uma <b>função</b>.
                            <ul>
                                <li>O benefício é que ela pode acessar o <b>contador</b> no <b>parent scope</b>.</li>
                                <li>Isso é chamado de <b>Javascript Closure</b>. </li>
                                <li>O contador é <b>protegido</b> pelo <b>escopo da função anônima</b> e só pode ser <b>alterado</b> usando-se a função <code class="inlineCode">add()</code>.</li>
                            </ul>
                        </li>
                    </ul>
                    <br>
                    <hr>
                    <br>
                    <p>
                        <b>variableName</b><br>
                        Apenas o nome da variável, sem parênteses, irá mostrar apenas o próprio código que foi passado para a variável<br>
                    </p>
                    <p>
                        <b>variableName()</b><br>
                        O nome da variável, com parênteses no final, irá executar a function que foi atribuída à variável.
                    </p>
                    <p>
                        <b>Exemplo:</b>
                    </p>
                    <pre class="preTag px-4">
                        <code>
function person() {
    let name = 'Peter';
    return function displayName() {
        console.log(name);
    };
}


let variableName = person();
variableName();                 //WILL RETURN "Peter"
console.log(variableName());    /*WILL RETURN "Peter" AND "undefined", the former linked to the line where the console.log was written and the latter linked to the line where the command itself was written */
console.log(variableName);      //WILL RETURN THE WHOLE FUNCTION THAT HAS BEEN ASSIGNED TO "variableName"
                        </code>
                    </pre>
                </div>
            </div>
        </div>

        <div class="container-lg">
            <div class="content">
                <div class="boundingLines"></div>
                <h2 class="px-4 mt-5 mb-4"><mark class="lineText">Um Problema do Contador</mark></h2>
                <div class="px-5">
                    <p>
                        Suponha que você queira usar uma variável para contar algo e que esse contador esteja disponível para todas as funções do programa: <br><br>
                        Você pode usar uma <b>variável global</b> e uma <b>função</b> para aumentar o contador <br>
                        Exemplo: <br>
                        <!-- <img src="1.jpg"> -->
                        O problema com essa solução é que qualquer código introduzido na página pode alterar o contador, <b>sem chamar</b> o add(). <br>
                    </p>
                    <p>
                        O contador deve ser local para a função add(), para prevenir que outros códigos possam alterá-lo: <br>
                        <!-- <img src="2.jpg"> -->
                        Não funcionou pois exibimos o contador global, e não o contador local. <br>
                    </p>
                    <p>
                        Podemos remover o contador global e acessar o contador local, permitindo que agora a função retorn o contador local: <br>
                        <!-- <img src="2.jpg"> -->
                        Não funcionou pois o contador local está sendo <b>zerado</b> toda vez que a função é chamada. <br>
                    </p>
                    <p>Uma <strong class="gold">Inner Function</strong> do JavaScript pode resolver isso<br></p>
                    <br><hr><br>
                    <h3>Nested Functions</h3>
                    <ul>
                        <li><b>Todas</b> funções têm acesso ao <b>escopo global</b>.</li>
                            <ul><li>Mais detalhadamente, em JavaScript, todas as funções terão acesso a todos os escopos que estão diretamente "acima" delas (Acesso a todos os escopos que as contêm). </li></ul>
                    </ul>
                    <ul>
                        <li>O JavaScript oferece suporte a <strong>nested functions</strong>.
                            <ul><li>As nested functions têm acesso aos escopos que estão "acima" delas. <br></li></ul>
                    </ul>
                        <p>Exemplo: A função interna <code class="inlineCode">plus()</code> tem acesso a variável do contador na <b>parent function</b></p>
                        <pre class="preTag px-4">
                            <code>
        document.getElementById("demo").innerHTML = add();
        function add() { //Parent Function
            let counter = 0;
            function <b>plus()</b> {
                counter += 1;
            }
            plus();  
            return counter; 
        }
                            </code>
                        </pre>
                    <ul>
                        <li>Isso poderia ter resolvido o problema do contador, se pudéssemos alcançar a função plus() de fora.</li>
                        <li>Também precisamos encontrar uma maneira de executar o counter = 0 apenas uma vez.</li>
                        <li>Para isso será necessário uma "closure"</li>
                    </ul>
                    <br><hr><br>
                </div>
            </div>
        </div>

        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
    </body>
</html>